Corine Smith

Log for PHZ 3150, Spring 2022

***** IN:  Tues Jan 11 15:17:37 EST 2022

Made a directory for the class here: 
/PHZ_3150.log

I opened my terminal and new directory then right clicked to select new folder(s) to create:

/PHZ_3150_Handin.log
and 
/PHZ_3150_Homework.log
and
/PHZ_3150_Demos.log

I opened notepad, started this log, saved as: 
/PHZ_3150_handin/hw1_Smith.log 

I then copy-pasted the questionnaire and filled it in here:

UCF Physics PHZ 3150: Introduction to Numerical Computing

Name:Corine Smith
Email:cmsengineering@knights.ucf.edu
Phone:250-151-1175
Major:(Double Major) Physics and Photonics Science and Engineering 
Year:2nd 
ID:5367851
How did you hear about this course? Academic Advisor
Do you have a laptop you can bring to class, install software on, etc.? Yes
What operating system and version does it run? Windows 10 Home
How much free disk space does it have? 402GB
What operating systems are you comfortable working in? Windows, Origin
What computer classes have you taken, including high school,
extracurricular, etc.? None
Have you ever programmed a computer? No
In what language(s)? N/A
Summarize your experience:
Have you taken statistics or probability? No
Why are you taking this course? Its a skill that will immensely help me in my research work 
Are there particular topics you hope to learn? General coding focused on physics 
If you have worked with scientific data or modeling before, briefly
describe your experience: Yes, I have experience curve fitting and data manipulation in Origin
Have you ever been involved with a science club or similar?  If so,
describe: I am a research assistant at UCF for Dr M Vaida in a Ultrashort Laser Lab that focuses on Photocatalysis (Charge carrier dyanamics, Synthesis and Characterization of 2D nanostructures, Ultrafast Molecular dynamics)


***** OUT:  Tues Jan 11 15:25:45 EST 2022

***** IN:  Tues Jan 11 18:53:15 EST 2022

Made a new directory for books here:
/PHZ_3150_Books.log

I used the link provided in the PHZ3150 syllabus to search for "Thinkpython2" and downloaded the PDF, saving it to the book directory in PHZ 3150. 

https://greenteapress.com/thinkpython2/thinkpython2.pdf

I then copied this log here:
/PHZ_3150_Handin_HW1_Smith.log 

I right clicked and zipped/compressed this file, then uploaded it onto webcourses.


***** OUT:  Tues Jan 11 18:58:45 EST 2022

***** IN:  Thurs Jan 13 12:50:59 EST 2022

Opened files on webcourses for computer installations. 

Accepted application for github by clicking on link provided for classroom. 

Downloaded minconda 3.9 windows 64 bit. Updated conda installation packages, installed numpy, scipy, ipython, matplotlib.

Downloaded Atom text editor from atom.io website 

***** OUT: Thurs Jan 13 13:12:21 EST 2022

***** IN: Tues Jan 18 16:47:35 EST 2022

Homework 2 Answers 

=== Problem 1 ===

On Jan 15 2022 Downloaded both Jupyter and Spyder software and saved to menu bar 
I found the commands for the downloads on the installation handout from files in the PHZ 3150 course, following:

https://www.spyder-ide.org/

I opened Anaconda and printed command: 

conda install syder 

This installed Spyder in my start menu
HW2_CSmith_Problem1a_ScreenshotSpyder.png

I installed Jupyter from the same instructions on the installation handout:

https://jupyter.org/install

I opened Anaconda and printed command: 

conda install jupyter
 
This installed Jupyter in my start menu
HW2_CSmith_Problem1a_ScreenshotJupyter.png

A) 

Installed version of Python 3
HW2_CSmith_Problem1a_ScreenshotPythonVersion.png

B)

Installed GitHub desktop and named it PHZ3150
HW2_CSmith_Problem1b_ScreenshotGitHubDesktop.png

=== Problem 2 ===

My f@vour*te physi#st is Ric$ard Feynman. 

Physicist favourite Richard Feynman my is. 

When employing programming language, natural language raises difficulties due to ambiguity, redundancy, and literalness.  Programming requires clear and concise statements that are unambiguous in any context, and are without unneeded dialogue or phrases. It is also important in programming language that the text is literal, and free from any figures of speech or allegory. 

***** OUT: Tues Jan 18 17:45:25 EST 2022

***** IN: Wed Jan 19 14:16:10 EST 2022

Homework 2 Answers 

=== Problem 1 ===

On Jan 15 2022 Downloaded both Jupyter and Spyder software and saved to menu bar 
I found the commands for the downloads on the installation handout from files in the PHZ 3150 course, following:

https://www.spyder-ide.org/

I opened Anaconda and printed command: 

conda install syder 

This installed Spyder in my start menu
Screen capture taken via snapshot command WINDOWS+SHIFT+S
Saved screen capture as HW2_CSmith_Problem1a_ScreenshotSpyder.png

I installed Jupyter from the same instructions on the installation handout:

https://jupyter.org/install

I opened Anaconda and printed command: 

conda install jupyter
 
This installed Jupyter in my start menu
Screen capture taken via snapshot command WINDOWS+SHIFT+S
Saved screen capture as HW2_CSmith_Problem1a_ScreenshotJupyter.png

= A = 

Installed version of Python 3
Screen capture taken via snapshot command WINDOWS+SHIFT+S
Saved screen capture as HW2_CSmith_Problem1a_ScreenshotPythonVersion_Toprightcorner.png

= B =

Installed GitHub desktop and named it PHZ3150
Screen capture taken via snapshot command WINDOWS+SHIFT+S
Saved screen capture as HW2_CSmith_Problem1b_ScreenshotGitHubDesktop.png

=== Problem 2 ===

My f@vour*te physi#st is Ric$ard Feynman. 

Physicist favourite Richard Feynman my is. 

When employing programming language, natural language raises difficulties due to ambiguity, redundancy, and literalness.  Programming requires literal, clear, formal and concise statements that are unambiguous in any context, and are without unneeded dialogue or phrases. It is important in programming language must be free from these undesirable traits present in natural language so it may determine and understand the exact command being given.

=== Problem 3 ===

Opened link provided from webcourses
 https://guides.github.com/activities/hello-world/
and completed hello-world tutorial

Created new repository for HW_survey.txt in Github HW1 and pushed to origin. 
Screen capture taken via snapshot command WINDOWS+SHIFT+S
Saved screen capture as HW2_CSmith_Problem3_Screenshotsurvey.txt_Desktop

Opened class directory in web browser, navigated to HW1, and viewed added file.
Screen capture was taken via snapshot command WINDOWS+SHIFT+S
Saved screen capture as HW2_CSmith_Problem3_Screenshotsurvey.txt_Web

End of HW2 

***** OUT: Wed Jan 15:09:45 EST 2022

***** IN: Tues Jan  25 15:18:46 EST 2022

Homework 3 Answers

=== Problem 1 ===

Homework 3 folder made:
PHZ3150_Handin_HW3

=== Problem 2 ===

= A =

I downloaded the GitHub desktop app in a previous lecture, then I opened the desktop GitHub app and followed the following paths to create a new repository:

File_New Repository

Where I named this new repository:

PHZ3150

After naming it I created the repository than pushed repository to web browser GitHub site

= B =

I drag and dropped my log into the Github web browser

CMSPhysics_PHZ3150

It is named 0-PHZ3150-CSmith.log and then commited the changes.  I think went to the GitHub desktop app, refreshed from origin, then pulled from origin to synch the GitHub browser with the GitHub app.

I opened the GitHub web brower and opened 

CMSPhysiscs_PHZ3150

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW3_CSmith_Problem2BII_Screenshot1.png

= C = 

I then created a new folder named test_git and saved it under revision control in:

CMSPhysics_PHZ3150

= D = 

I copied and pasted the hw1-survey.txt into the new test_git folder. In GitHub desktop I committed the changes and took a screenshot.

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW3_CSmith_Problem2D_Screenshot2.png

I then pushed these changes to origin. 

I then deleted hw1-survey.txt from the test_git folder, and added the comment Removal as per HW3 problem 2d.

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW3_CSmith_Problem2D_Screenshot3.png

= E =

I took a screenshot of my history of the changes on the GitHub desktop app.

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW3_CSmith_Problem2E_Screenshot4.png

=== Problem 3 ===

I opened Jupyter Notebook and started a new Python notebook and named it:

hw3_CSmith_test_notebook. 

I defined the variables x,y, z, w, and q, and performed a multiplication of x and y, subtracted y and x, added 1 to q, and multpilied q by 10.  

I defined a min function to equal 3 and explained in the notebook why the name is erroneous. 

***** OUT: Tues Jan 25 16:00:26 EST 2022

***** IN: Sat Jan 29 13:33:23 EST 2022

Homework 4 Answers

=== Problem 1 ===

Homework 4 folder made:
PHZ3150_Handin_HW4

This folder was then committed and pushed in Github.

=== Problem 2 ===

I created a new python file named:
hw4_CSmith

I created a function to Force [N] from mass[Kg] and acceleration[m/s^2], and printed results for a list of masses and acceleration values.

I created a Force[N] to Acceleration[m/s^2] function, and calculated the acceleration from a list of forces with corresponding mass [150Kg].

=== Problem 3 ===

I opened a new python file named:
acceleration_hw4.py 

I created a function for acceleration from the change in speed [u1 and u2] divided by the change in time [t1, t2].

In the hw4_CSmith python file, I imported the function acceleration and calculated the acceleration for a list of u1, u2, t1, and t2 values.

I verified these results by computing the calculations by hand with a graphing calulator. 

2 possible ways to determine that the code I wrote functions correctly are: 1) compute iterations by hand as I have done above and 2) use another program with built in code/functions such as excel to verify results

***** OUT: Sat Jan 29 14:55:02 EST 2022

***** IN: Sun Jan 30 16:16:34 EST 2022

=== Problem 4 ===

In the hw4_CSmith python file, I imported the function acceleration from acceleration_hw4.py and input values from the hw4 file for velocity and time.

I changed the 5th element in my velocity list to 90 

It did not successfully print as the acceleration function was defined for speed variables u1, u2 and time variables t1 and t2, not for overall velocity and time. 

I copied and pasted my hw4 folder to:

PHZ3150_handin_hw4

Commited these changes on the Github desktop app, pushed the changes to origin and took a screen capture of the changes on the webbrowser.

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW4_CSmith_Problem4_Screenshot1.png

***** OUT: Sun Jan 30 16:52:45 EST 2022

***** IN: Mon Jan 31 08:16:45 EST 2022

Homework 4 Answers

=== Problem 1 ===

Homework 4 folder made:

PHZ3150_Handin_HW4

This folder was then committed with the comment hw4_Smith and the changes were pushed in Github.

=== Problem 2 ===

I created a new python file named:
hw4_CSmith

I created a function to Force [N] from mass[Kg] and acceleration[m/s^2], and printed results for a list of masses and acceleration values.

I created a Force[N] to Acceleration[m/s^2] function, and calculated the acceleration from a list of forces with corresponding mass [150Kg].

=== Problem 3 ===

I opened a new python file named:
acceleration_hw4.py 

I created a function for acceleration from the change in speed [u1 and u2] divided by the change in time [t1, t2].

In the hw4_CSmith python file, I imported the function acceleration and calculated the acceleration for a list of u1, u2, t1, and t2 values.

I verified these results by computing the calculations by hand with a graphing calulator. 

2 possible ways to determine that the code I wrote functions correctly are: 1) Use Hypothesis (Library that allows you to generate examples to test to reveal any bugs that may be present in your code) and 2) use the doctest module in python that executes problems within a docstring to verify that the function works exactly as it should. 

=== Problem 4 ===

In the hw4_CSmith python file, I imported the function acceleration from acceleration_hw4.py and input values from the hw4 file for velocity and time.

I changed the 5th element in my velocity list to 90 

It did not successfully print as the acceleration function was defined for speed variables u1, u2 and time variables t1 and t2, not for overall velocity and time. 

I copied and pasted my hw4 folder to:

PHZ3150_handin_hw4

Commited these changes on the Github desktop app, pushed the changes to origin and took a screen capture of the changes on the webbrowser.

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW4_CSmith_Problem4_Screenshot1.png

I sent this log to my handin folder, where I right clicked and created a zipfile for my hw4 python files, this log, and the screen shot. 

I then uploaded the hw4_Smith zipfile to webcourses

End of HW4

***** OUT: Mon Jan 31 08:25:13 EST 2022

***** IN: Sun Feb 06 12:19:34 EST 2022

Homework 5 Answers 

=== Problem 1 ===

I read chapters 10 and 12 from thinkpython2

I created a new folder for HW5
PHZ3150_Handin_HW5_CSmith 

I created a new python file named:
hw5_CSmith.ipynb 
This python file is saved under PHZ3150_Handin_HW5_CSmith. This assignment was labelled with name, date, and assignment number.

I committed these changes to Github desktop app, and pushed the changes to origin. 

=== Problem 2 ====

I created a quadratic formula function named quadratic_function to calulate the roots of the given polynomial x^2-x-12=0
d = np.power( b, 2 ) - 4 * a * c 
solution1 = - np.power( b, 2 )  - np.sqrt( d ) / 2 * a 
solution2 = - np.power( b, 2 ) + np.sqrt( d ) / 2 * a 

I printed the results to this calulation. Initially giving me incorrect values [ -4.5 , 2.5 ] when verified by hand using graphing calculator. 
I fixed this problem by ensuring the numerator of my equation was in brakcets 

solution1 = ( - np.power( b, 2 )  - np.sqrt( d ) ) / 2 * a 
solution2 = ( - np.power( b, 2 ) + np.sqrt( d ) ) / 2 * a 

=== Problem 3 === 

I created a function to calculate student height from feet and inches to meters with the centimeters rounded to the nearest whole number. 

I then calculated and printed the following students heights:  
student_h = ( 5.01, 4.10, 6.02, 5.07,  6.11 )

I verified these results by hand with a graphing calculator

=== Problem 4 ====

I opened a new python file and named it 
displacement_function_hw5.py

In this file I created a displacement function that calculates displacement as a function of initial speed[ u_init ], constant acceleration[ a ], and time[ s ]
 s = u_init * t + 0.5 * a * np.power( t , 2 ) 

I imported this function from displacement_function_hw5.py to my hw5_CSmith file, then printed and computed the results for: 
u_init = [ 0 ]
a = [ 10 , 20 , 30 ]
t = [ 2 , 4 , 14 ]

I verified these results by hand using a graphing calculator. 

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_hw5_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW5_CSmith_Problem5_Screenshot1.png

I copied this log into my PHZ3150_handin_hw5_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 5 

***** OUT: Sun Feb 07 11:08:05 EST 2022 

***** IN: Wed Feb 09 13:34:33 EST 2022

Homework 5 Answers 

=== Problem 1 ===

I read chapters 10 and 12 from thinkpython2

I created a new folder for HW5
PHZ3150_Handin_HW5_CSmith 

I created a new python file named:
hw5_CSmith.ipynb 
This python file is saved under PHZ3150_Handin_HW5_CSmith. This assignment was labelled with name, date, and assignment number.

I committed these changes to Github desktop app, and pushed the changes to origin. 

=== Problem 2 ====

I created a quadratic formula function named quadratic_function to calulate the roots of the given polynomial x^2-x-12=0
d = np.power( b, 2 ) - 4 * a * c 
solution1 = - np.power( b, 2 )  - np.sqrt( d ) / 2 * a 
solution2 = - np.power( b, 2 ) + np.sqrt( d ) / 2 * a 

I printed the results to this calulation. Initially giving me incorrect values [ -4.5 , 2.5 ] when verified by hand using graphing calculator. 
I fixed this problem by ensuring the numerator of my equation was in brakcets 

solution1 = ( - np.power( b, 2 )  - np.sqrt( d ) ) / 2 * a 
solution2 = ( - np.power( b, 2 ) + np.sqrt( d ) ) / 2 * a 

The function returned the results:
[ -4.0 , 3.0 ]

=== Problem 3 === 

I imported math to this notebook:
import math 

I created a function to calculate student height from feet and inches to meters with the centimeters rounded to the nearest whole number:

def feet_to_meter_centimeter ( ft_In ):
    """Function that converts feet to meters and centimeters
    INPUT: feet [ ft ] , Inches [ In ]
    OUTPUT: meters [ m ], centimeters [ cm ] """
    
    Imperial_height = list(math.modf( ft_In ) )
    ft = Imperial_height[ 0 ]
    In = Imperial_height[ 1 ]
    m = round ( ( ft * 0.3048 + In * 0.0254 ) * 10 , 1 )
    cm = round( m * 10 ) 
    
    return [ m , cm ]

I then calculated and printed the following students heights:  
student_h = ( 5.01, 4.10, 6.02, 5.07,  6.11 )

The function returned the results with the informative sentance:

student 1 has height of: 1.0 m and 10 cm
student 2 has height of: 1.0 m and 10 cm
student 3 has height of: 2.0 m and 20 cm
student 4 has height of: 1.0 m and 10 cm
student 5 has height of: 2.0 m and 20 cm

I verified these results by hand with a graphing calculator

=== Problem 4 ====

I opened a new python file and named it 
displacement_function_hw5.py

In this file I created a displacement function that calculates displacement as a function of initial speed[ u_init ], constant acceleration[ a ], and time[ s ]
 s = u_init * t + 0.5 * a * np.power( t , 2 ) 

I imported this function from displacement_function_hw5.py to my hw5_CSmith file, then printed and computed the results for: 
u_init = [ 0 ]
a = [ 10 , 20 , 30 ]
t = [ 2 , 4 , 14 ]

The function returned the results:

20.0
160.0
2940.0

I verified these results by hand using a graphing calculator. 

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_hw5_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW5_CSmith_Problem5_Screenshot1.png

I copied this log into my PHZ3150_handin_hw5_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 5

***** OUT: Wed Feb 09 14:45:32 EST 2022

***** IN: Sat Feb 12 07:49:32 EST 2022

Homework 6 Answers 

=== Problem 1 ===

I created a new homework folder named HW6_CSmith:
PHZ3150_Homework_HW6_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I read chapters 8 & 11 in ThinkPython.

=== Problem 2 ===

I created a new python file in Jupyter Notebooks named hw6_csmith 

I imported numpy and matplotlib and created 3 arrays:

x = np.arange( 1, 101, 0.5)
y = np.log(x)
z = np.sqrt(x)

I plotted y(x) and z(x) on the same graph using the following parameters:
plt.figure( figsize = (8, 8 ) )
plt.plot  ( x, y,  color = 'red' , linestyle = '--', linewidth = 4) 
plt.plot  ( x, z, color = 'blue' , linestyle = '-', linewidth = 3)
plt.xlabel( 'x', fontsize = 20 )
plt.ylabel( 'log10(x) & sqrt(x)', fontsize = 20 )
plt.title( 'Y=log10(x) & Z=sqrt(x)' , fontsize = 30 )
plt.yticks( fontsize = 25 )
plt.xticks( fontsize = 25 )
plt.xlim( 0, 100 )
plt.tick_params(axis='both',which='major',length=12, width=4,direction='in')
plt.text( 40 , 6, 'z=sqrt(x)' , color = 'blue' , rotation = 30 , fontsize=20 )
plt.text( 40, 2, 'y=log10(x)' , color = 'red', rotation = 5 , fontsize=20 )
plt.yticks( np.arange( 0, 10, step = 1 ) ,fontsize=20 ) 
plt.xticks( np.arange( 0, 100, 10 ) ,fontsize=20 )

I saved this plot as a pdf:

plt.savefig( 'hw6_CSmith.pdf', format = 'pdf', 
            dpi = 1200, bbox_inches = 'tight', pad_inches = 0.3 )

=== Problem 3 ===

I created a new array
q = np.array([45 24  5 30  3 67 33 60 65 13 82 75 21 77 67  8 86 62 23 70 11 70 21 15 84 51  6 79 78 66  2 93 49 74 23 85 25 38  1 89])
I printed this array

I found and printed the locations of values of q > 50 using print(np.where( q > 50))

[ 5,  7,  8, 10, 11, 13, 14, 16, 17, 19, 21, 24, 25, 27, 28, 29, 31,
       33, 35, 39]

I found and printed the elements where 50<q<70 using print( q[ np.where ( (q > 50) & (q < 70) ) ] )

[67 60 65 67 62 51 66]

I created a list q_list from the array q and printed the values from elements 12 to 14 

[21 , 77 , 67 ]

I changed the 24th element of the list to the value 42.0.  This was succesful because list are mutable. 

I created a tuple called q_tuple from array q, and printed the 20th element 

70

Tuples are immutable, so I wasn't able to change element 21 to the value 44.0.  Tuples are static. 


***** OUT: Sat Feb 12 10:13:22 EST 2022

***** IN: Mon Feb 14 15:34:48 EST 2022

==== Problem 3 ===

I made a list of strings:
word_list =  [ 'twinkle' , 'twinkle' , 'little' , 'star']

I found the location and existance of the letters 'a' and 'e' in the list of strings. 

I wrote a code to determine if a word is present in my string list above word_list

if 'star' in word_list:
    print("star is present in string list")
else:
    print("star is not present in string list")
    
if 'bright' in word_list:
    print("bright is present in string list")
else:
    print("bright is not present in string list")

The solutions printed were:

star is present in string list
bright is not present in string list

=== Problem 4 ===

I created a dictionary and populated it with english words and their corresponding numbers up to and including 'twenty':20

I created a function word_to_number that takes the english word that corresponds to a number and returns the digit in the form of a statement "[word] is [digit]"

def word_to_number( key ):
    """Takes the english word corresponding to a number and returns the number as a digit
    Input: english number 
    Output: digit"""
    
    word_list =dict()
    word_list['one'] = 1
    word_list['two'] = 2
    word_list['three'] = 3
    word_list['four'] = 4
    word_list['five'] = 5
    word_list['six'] = 6 
    word_list['seven'] = 7
    word_list['eight'] = 8
    word_list['nine'] = 9
    word_list['ten'] = 10
    word_list['eleven'] = 11
    word_list['twelve'] = 12
    word_list['thirteen'] = 13
    word_list['fourteen'] = 14 
    word_list['fifteen'] = 15
    word_list['sixteen'] = 16
    word_list['seventeen'] = 17
    word_list['eighteen'] = 18
    word_list['nineteen'] = 19
    word_list['twenty'] = 20
    
    value = word_list.get( key )
    
    print( key, 'is', value )
        
    return value

I called the functioin for the dictionary values three, seven, twelve, sixteen, nineteen.

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_hw6_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW6_CSmith_Problem5_Screenshot1.png

I copied this log into my PHZ3150_handin_hw6_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 6

***** OUT: Mon Feb 14 16:25:17 EST 2022

***** IN: Tues Feb 15 15:06:03 EST 2022

Homework 6 Answers 

=== Problem 1 ===

I created a new homework folder named HW6_CSmith:
PHZ3150_Homework_HW6_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I read chapters 8 & 11 in ThinkPython.

=== Problem 2 ===

I created a new python file in Jupyter Notebooks named hw6_csmith 

I imported numpy and matplotlib and created 3 arrays:

x = np.arange( 1, 101, 0.5)
y = np.log(x)
z = np.sqrt(x)

I plotted y(x) and z(x) on the same graph using the following parameters:
plt.figure( figsize = (8, 8 ) )
plt.plot  ( x, y,  color = 'red' , linestyle = '--', linewidth = 4) 
plt.plot  ( x, z, color = 'blue' , linestyle = '-', linewidth = 3)
plt.xlabel( 'x', fontsize = 20 )
plt.ylabel( 'log10(x) & sqrt(x)', fontsize = 20 )
plt.title( 'Y=log10(x) & Z=sqrt(x)' , fontsize = 30 )
plt.yticks( fontsize = 25 )
plt.xticks( fontsize = 25 )
plt.xlim( 0, 100 )
plt.tick_params(axis='both',which='major',length=12, width=4,direction='in')
plt.text( 40 , 6, 'z=sqrt(x)' , color = 'blue' , rotation = 30 , fontsize=20 )
plt.text( 40, 2, 'y=log10(x)' , color = 'red', rotation = 5 , fontsize=20 )
plt.yticks( np.arange( 0, 10, step = 1 ) ,fontsize=20 ) 
plt.xticks( np.arange( 0, 100, 10 ) ,fontsize=20 )

I saved this plot as a pdf:

plt.savefig( 'hw6_CSmith.pdf', format = 'pdf', 
            dpi = 1200, bbox_inches = 'tight', pad_inches = 0.3 )

=== Problem 3 ===

I created a new array
q = np.array([45 24  5 30  3 67 33 60 65 13 82 75 21 77 67  8 86 62 23 70 11 70 21 15 84 51  6 79 78 66  2 93 49 74 23 85 25 38  1 89])
I printed this array

I found and printed the locations of values of q > 50 using print(np.where( q > 50))

[ 5,  7,  8, 10, 11, 13, 14, 16, 17, 19, 21, 24, 25, 27, 28, 29, 31,
       33, 35, 39]

I found and printed the elements where 50<q<70 using print( q[ np.where ( (q > 50) & (q < 70) ) ] )

[67 60 65 67 62 51 66]

I created a list q_list from the array q and printed the values from elements 12 to 14 

[21 , 77 , 67 ]

I changed the 24th element of the list to the value 42.0.  This was succesful because list are mutable. 

I created a tuple called q_tuple from array q, and printed the 20th element 

70

Tuples are immutable, so I wasn't able to change element 21 to the value 44.0.  Tuples are static. 


I made a list of strings:
word_list =  [ 'twinkle' , 'twinkle' , 'little' , 'star']

I found the location and existance of the letters 'a' and 'e' in the list of strings. 

I wrote a code to determine if a word is present in my string list above word_list

if 'star' in word_list:
    print("star is present in string list")
else:
    print("star is not present in string list")
    
if 'bright' in word_list:
    print("bright is present in string list")
else:
    print("bright is not present in string list")

The solutions printed were:

star is present in string list
bright is not present in string list

=== Problem 4 ===

I created a dictionary and populated it with english words and their corresponding numbers up to and including 'twenty':20

I created a function word_to_number that takes the english word that corresponds to a number and returns the digit in the form of a statement "[word] is [digit]"

def word_to_number( key ):
    """Takes the english word corresponding to a number and returns the number as a digit
    Input: english number 
    Output: digit"""
    
    word_list =dict()
    word_list['one'] = 1
    word_list['two'] = 2
    word_list['three'] = 3
    word_list['four'] = 4
    word_list['five'] = 5
    word_list['six'] = 6 
    word_list['seven'] = 7
    word_list['eight'] = 8
    word_list['nine'] = 9
    word_list['ten'] = 10
    word_list['eleven'] = 11
    word_list['twelve'] = 12
    word_list['thirteen'] = 13
    word_list['fourteen'] = 14 
    word_list['fifteen'] = 15
    word_list['sixteen'] = 16
    word_list['seventeen'] = 17
    word_list['eighteen'] = 18
    word_list['nineteen'] = 19
    word_list['twenty'] = 20
    
    value = word_list.get( key )
    
    print( key, 'is', value )
        
    return value

I called the functioin for the dictionary values three, seven, twelve, sixteen, nineteen.

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_hw6_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW6_CSmith_Problem5_Screenshot1.png

I copied this log into my PHZ3150_handin_hw6_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 6

***** OUT: Mon Feb 15 16:25:17 EST 2022

***** IN: Thurs Feb 17 16:08:13 EST 2022

Start of Homework 7

=== Problem 1 ===

I created a new homework folder named HW7_CSmith:
PHZ3150_Homework_HW7_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I read chapters 5 & 7 in ThinkPython.

I created a new Jupyter notebook, renamed it as HW7_CSmith, and imported numpy as np

=== Problem 2 ===

I created a string named sentence that contained the phrase “Deleting an item from a list or array while 
iterating over it is a Python problem that is well known to any experienced software 
developer”

I used the command sentence.split() to split the sentence into individual words in a list named word_list, and printed this list.

I then used the following for/in code to print the longest word of word_list

max_word = word_list[ 0 ]

for words in word_list: 
    if len( words ) > len(max_word):
        max_word = words

This printed the word of the maximum length in the list "experienced"

I then used the following while loop to print the longest word of word_list

i = 0
while len(max_word) > len(word_list[i]):
    print(max_word)
    i += 1

It printed the word of the maximum length in the list 'experienced".

I then printed the first 4 words of word_list, and printed out a list of the unique letters contained within these 4 words.

for i in range(0,len(s)):
    flag = 0 
    for j in range(0,len(s)):
        if (s[i]==s[j] and i != j):
            flag = 1
            break
    if(flag == 0):
        print(s[i], end="")

The unique letters in the first six words of word_list are:
Dgfros

***** OUT: Thurs Feb 17 17:01:53 EST 2022

***** IN: Fri Feb 18 13:30:52 EST 2022

=== Problem 3 ===

I created a separate text file in jupyter called HW7_support_function.py

I created a function named circle that gives the y values of a circle when the values [x, x0, y0, r] are given with the formula:
 
y = np.sqrt((r**2)-(x-x0)**2)+y0

I called this function into my main homework file HW7_CSmith, and then called the y values for the inputs values of:

x0 = 2
y0 = 2
x = -8.+0.1*np.arange(220)
r = 10
y_values = circle(x,x0,y0,r)

print(y_values)

This printed a y_valus array.

I made an array y = y_values. I received a warning/error:

RuntimeWarning: invalid value encountered in sqrt
  y = np.sqrt((r**2)-(x-x0)**2)+y0

I then imported matplotlib.plt as plt, and I graphed this circle function with the following parameters:

plt.figure( figsize = (8, 8 ) )
plt.plot  ( x, y,  color = 'red' , linestyle = '-', linewidth = 4) 
plt.xlabel( 'x', fontsize = 30 )
plt.ylabel( 'y(x)', fontsize = 30 )
plt.title( 'Circle' , fontsize = 30 )
plt.yticks( fontsize = 30 )
plt.xticks( fontsize = 20 )

Initially my function printed out a semi circle not a complete circle as it didnt return the negative y values and postive y values. I changed this by creating two seperate equations in the circle function to account for both the negative and postive y values, and then plotted both arrays of y values as a function of x. 

I changed my function to:

def circle(x,x0,y0,r):
    """Function that takes an array of x, the circles centre coordinates x0, y0, and radius r, and returns all y coordinates.
    Input: xarray[x], centre coordinates[ x0, y0], radius[r]
    Output: yarray[y]"""
    
    y1 = y0-np.sqrt((r**2)-(x-x0)**2)
    y2 = y0+np.sqrt((r**2)-(x-x0)**2)
    
    return [y1,y2]

I then plotted both y1 and y2:

plt.figure( figsize = (8, 8 ) )
plt.plot  ( x, y[0],color = 'red' , linestyle = '-', linewidth = 4) 
plt.plot  ( x, y[1],color = 'red' , linestyle = '-', linewidth = 4) 
plt.xlabel( 'x', fontsize = 30 )
plt.ylabel( 'y(x)', fontsize = 30 )
plt.title( 'Circle' , fontsize = 30 )
plt.yticks( fontsize = 30 )
plt.xticks( fontsize = 20 )

This returned the correct circle. 

=== Problem 4 ===

I created another function in my HW7_support_function.py text file named order_array.  This function takes an input array and orders them from small to large. 
 
    for i in range(len(input_array)):
        for j in range(i + 1, len(input_array)):
            if input_array[i] > input_array[j]:
                input_array[i], input_array[j] = input_array[j], input_array[i]
                
                print (input_array)

I imported this function into my main homework file HW7_CSmith using from HW7_support_function import order_array

I ran the code with the values input_array = np.array([4,5,2,10,42,22,8,12])

It returned [2 4 5 8 10 12 22 42 ] 

I verified this result with a numpy command:

print(np.sort(input_array))

which returned the same result as the code. Verified. 

=== Bonus Problem ===

for i in range(6):
    k=1
    for j in range(i+1):
        print(k%2, end = " ")
        k += 1
    print("")
for i in range(5):
    k = 1
    for j in range(5-i):
        print(k%2, end = " ")
        k += 1 
    print("")

printed the result:

1 
1 0 
1 0 1 
1 0 1 0 
1 0 1 0 1 
1 0 1 0 1 0 
1 0 1 0 1 
1 0 1 0 
1 0 1 
1 0 
1 

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_hw7_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW7_CSmith_Problem5_Screenshot1.png

I copied this log into my PHZ3150_handin_hw7_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 7

***** OUT: Fri Feb 18 17:52:02 EST 2022

***** IN: Sun Feb 20 11:01:45 EST 2022

Midterm Project Answers 

=== Problem 1 ===

I created a new folder named Midterm_CSmith:
PHZ3150_Midterm_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I imported numpy as np
I imported math 

=== Problem 2 ===

I created input codes for the starting location and destination locations, including an informative statement. 

start_location = input('Which location are you starting?')
destination_location = input('Which location are you arriving?')

I created a list named:

planets_and_moons

It was populated with ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']

I wrote a code that checks for the validity of the start location and destination location that includes an informative statement that allows traveller to proceed if they pick a valid choice, or prompts the traveller to choose from the planets_and_moons list.

for start in planets_and_moons:
    if start_location == planets_and_moons:
        print(start_location, "is an allowed starting location, please proceed!")
    if start_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
        start_location = input( "Please select a valid starting location")

for finish in planets_and_moons:
    if destination_location == planets_and_moons:
        print(destination_location, 'is an allowed destination please proceed!')
    if destination_location not in planets_and_moons:
        print("Sorry", destination_location, "is not a valid destination location. Please choose from the following available starting locations", planets_and_moons)
        destination_location = input("Please select a valid destination location")

I tested this function by inputting the start location "Desmos" and destination location "Io".

This returned the following results:

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot1.png

I then followed the code prompts to pick the starting location "Jupiter" ,and recieved the following response:

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot2.png

=== Problem 3 ===

I used numpy to read the data of solar_system_1.dat:

space_distances_data1 = np.loadtxt('../demos/solar_system_date_1.dat')

***** OUT: Sun Feb 20 13:23:07 EST 2022

***** IN: Sun Feb 20 19:54:12 EST 2022

Start of Homework 7

=== Problem 1 ===

I created a new homework folder named HW7_CSmith:
PHZ3150_Homework_HW7_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I read chapters 5 & 7 in ThinkPython.

I created a new Jupyter notebook, renamed it as HW7_CSmith, and imported numpy as np

=== Problem 2 ===

I created a string named sentence that contained the phrase “Deleting an item from a list or array while 
iterating over it is a Python problem that is well known to any experienced software 
developer”

I used the command sentence.split() to split the sentence into individual words in a list named word_list.

I then used a code:

for i in word_list:
    print(i)

To scan this list for the individual words. 

I then used the following for/in code to print the longest word of word_list

max_word = word_list[ 0 ]

for words in word_list: 
    if len( words ) > len(max_word):
        max_word = words

This printed the word of the maximum length in the list "experienced"

I then used the following while loop to print the longest word of word_list

i = 0
while len(max_word) > len(word_list[i]):
    print(max_word)
    i += 1

It printed the word of the maximum length in the list 'experienced".

I then printed the first 4 words of word_list, and printed out a list of the unique letters contained within these 4 words.

for i in range(0,len(s)):
    flag = 0 
    for j in range(0,len(s)):
        if (s[i]==s[j] and i != j):
            flag = 1
            break
    if(flag == 0):
        print(s[i], end="")

The unique letters in the first six words of word_list are:
Dgfros

=== Problem 3 ===

I created a separate text file in jupyter called HW7_support_function.py

I created a function named circle that gives the y values of a circle when the values [x, x0, y0, r] are given with the formula:
 
y = np.sqrt((r**2)-(x-x0)**2)+y0

I called this function into my main homework file HW7_CSmith, and then called the y values for the inputs values of:

x0 = 2
y0 = 2
x = -8.+0.1*np.arange(220)
r = 10
y_values = circle(x,x0,y0,r)

print(y_values)

This printed a y_valus array.

I made an array y = y_values. I received a warning/error:

RuntimeWarning: invalid value encountered in sqrt
  y = np.sqrt((r**2)-(x-x0)**2)+y0

I then imported matplotlib.plt as plt, and I graphed this circle function with the following parameters:

plt.figure( figsize = (8, 8 ) )
plt.plot  ( x, y,  color = 'red' , linestyle = '-', linewidth = 4) 
plt.xlabel( 'x', fontsize = 30 )
plt.ylabel( 'y(x)', fontsize = 30 )
plt.title( 'Circle' , fontsize = 30 )
plt.yticks( fontsize = 30 )
plt.xticks( fontsize = 20 )

Initially my function printed out a semi circle not a complete circle as it didnt return the negative y values and postive y values. I changed this by creating two seperate equations in the circle function to account for both the negative and postive y values, and then plotted both arrays of y values as a function of x. 

I changed my function to:

def circle(x,x0,y0,r):
    """Function that takes an array of x, the circles centre coordinates x0, y0, and radius r, and returns all y coordinates.
    Input: xarray[x], centre coordinates[ x0, y0], radius[r]
    Output: yarray[y]"""
    
    y1 = y0-np.sqrt((r**2)-(x-x0)**2)
    y2 = y0+np.sqrt((r**2)-(x-x0)**2)
    
    return [y1,y2]

I then plotted both y1 and y2:

plt.figure( figsize = (8, 8 ) )
plt.plot  ( x, y[0],color = 'red' , linestyle = '-', linewidth = 4) 
plt.plot  ( x, y[1],color = 'red' , linestyle = '-', linewidth = 4) 
plt.xlabel( 'x', fontsize = 30 )
plt.ylabel( 'y(x)', fontsize = 30 )
plt.title( 'Circle' , fontsize = 30 )
plt.yticks( fontsize = 30 )
plt.xticks( fontsize = 20 )

This returned the correct circle. 

=== Problem 4 ===

I created another function in my HW7_support_function.py text file named order_array.  This function takes an input array and orders them from small to large. 
 
    for i in range(len(input_array)):
        for j in range(i + 1, len(input_array)):
            if input_array[i] > input_array[j]:
                input_array[i], input_array[j] = input_array[j], input_array[i]
                
                print (input_array)

I imported this function into my main homework file HW7_CSmith using from HW7_support_function import order_array

I ran the code with the values input_array = np.array([4,5,2,10,42,22,8,12])

It returned [2 4 5 8 10 12 22 42 ] 

I verified this result with a numpy command:

print(np.sort(input_array))

which returned the same result as the code. Verified. 

=== Bonus Problem ===

for i in range(6):
    k=1
    for j in range(i+1):
        print(k%2, end = " ")
        k += 1
    print("")
for i in range(5):
    k = 1
    for j in range(5-i):
        print(k%2, end = " ")
        k += 1 
    print("")

printed the result:

1 
1 0 
1 0 1 
1 0 1 0 
1 0 1 0 1 
1 0 1 0 1 0 
1 0 1 0 1 
1 0 1 0 
1 0 1 
1 0 
1 

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_hw7_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW7_CSmith_Problem5_Screenshot1.png

I copied this log into my PHZ3150_handin_hw7_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 7

***** OUT: Sun Feb 20 20:05:02 EST 2022

***** IN: Sat Feb 26 14:02:03 EST 2022

Midterm Project Answers 

=== Problem 1 ===

I created a new folder named Midterm_CSmith:
PHZ3150_Midterm_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I imported numpy as np
I imported math 
I imported pandas as pd 
I imported sys 

=== Problem 2 ===

= A = 

I created input codes for the starting location and destination locations, including an informative statement. 

start_location = input('Which location are you starting?')
destination_location = input('Which location are you arriving?')

= B =

I created a list named:


planets_and_moons

It was populated with ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']

= C = 

I wrote a code that checks for the validity of the start location and destination location that includes an informative statement that allows traveller to proceed if they pick a valid choice, or prompts the traveller to choose from the planets_and_moons list.

for start in planets_and_moons:
    if start_location == planets_and_moons:
        print(start_location, "is an allowed starting location, please proceed!")
    if start_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
        start_location = input( "Please select a valid starting location")

for finish in planets_and_moons:
    if destination_location == planets_and_moons:
        print(destination_location, 'is an allowed destination please proceed!')
    if destination_location not in planets_and_moons:
        print("Sorry", destination_location, "is not a valid destination location. Please choose from the following available starting locations", planets_and_moons)
        destination_location = input("Please select a valid destination location")

= D1 = 

I tested this function by inputting the start location "Desmos" and destination location "Io".

This returned the following results:

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot1.png

= D2 = 

I then followed the code prompts to pick the starting location "Jupiter" ,and recieved the following response:

I received the answer "Jupiter is a valid starting location, please proceed!"

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot2.png

= Bonus =

I used a while true loop to loop through correct input start and destination locations, with an if/not loop for incorrect locations.  If continued invalid locations are entered it continues to input prompt for valid locations.  If the correct location is entered, the loop breaks and informs the user that the location chosen is valid. 

while True:
    start_location = input('Which location are you starting?')
    destination_location = input('Which location are you arriving?')
    planets_and_moons = ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']
    
    if start_location and destination_location in planets_and_moons:
        print(start_location, 'is an allowed destination please proceed!', destination_location, 'is an allowed destination please proceed!')
        break
    if start_location and destination_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
       
    
    continue 

=== Problem 3 ===

= A =

I used numpy to read the data from space_distances_date1:

space_distances_date1 = np.loadtxt('../demos/solar_system_date_1.dat')

= B =

I used pandas to index the data:

df = pd.DataFrame(space_distances_date1, columns = planets_and_moons, index = planets_and_moons)
start_body_i = start_location
destination_body_i = destination_location
distance_for_traveller = df.loc[start_body_i, destination_body_i]

= C =

I printed the distance for space_distance_date1 starting at Jupiter and ending at Io:

"You will travel 0.0029 AU if you start from Jupiter and arrive at Io!"

= D = 

I wrote a code that determines the time in years, days, hours, and minutes that the trip will take:

time_total = distance_for_traveller / 0.001

time_years = int((time_total / 24)*(1/365))
d = (((time_total/365)-time_years)*365)/24
time_days = int(d)
h = (d-time_days)*24
time_hours = int(h)
m = (h-time_hours)*60
time_minutes = int(m)

print("Your trip will take,", time_years, "years,", time_days, "days,", time_hours, "hours, and", time_minutes, "minutes")

This code for the trip from Jupiter to Io returned the result:

Your trip will take, 0 years, 0 days, 2 hours, and 53 minutes

= E = 

I created a function planet_tour1 saved in a seperate file planet_tour1.py that takes the input destination and output destination and returns the travel distance and travel time in years, days, hours, and minutes. 

= F = 

I imported the planet_tour1 function and ran it for a starting location of Earth and a destination location of Mars. It returned:

"The distance from Earth to Mars is 2.113 AU and this trip will take 0 years, 88 days, 1 hour, and 0 minutes. 

=== Problem 4 === 

= A = 

I made the changes to my function planet_tour1 to include a code that checks for how many stops this trip needs to make to refuel, assuming that the ship's tank is completely full when departing, adnt that refueling is required every 0.65AU.

I imported the updated planet_tour2 function, and ran the code for a trip from Earth to Mars:

"The distance from Earth to Mars is 2.113 AU and this trip will take 0 years 88 days, 1 hours, and 0 minutes

You will require 4 refuelling stops"

= B = 

I updated the function to include code that will write a file messages_to_stations.txt to inform the station the start location, destination location, and at what fueling stations they will be stopping (0.65AU, 1.3AU, 1.95AU).
 
= C = 

I imported the function planet_tour3 and ran the code for trips: 1) Io to Jupiter, and 2) Earth to Venus, and this returned:

1) The distance from Io to Jupiter is 0.0029 AU and this trip will take 0 years 0 days, 2 hours, and 53 minutes

You will require 1 refuelling stops

2)The distance from Earth to Venus is 0.3915 AU and this trip will take 0 years 16 days, 7 hours, and 30 minutes

You will require 1 refuelling stops

I renamed the output message to message_to_stations1.txt.  I only have one message in the file, as I didnt append the message and because I kept it in write mode, the new text overwrote the previous message. 

=== Problem 5 ===

= A = 

I wrote a code in my function planet_tour4 that determines the shortest travel distance according to the day chosen to travel. 

 travel_dates = [distance_for_traveller1, distance_for_traveller2, distance_for_traveller3]
    

    df1 = pd.DataFrame(space_distance_data1, columns=planets_and_moons, index=planets_and_moons)
    distance_for_traveller1 = df1.loc[start_body_i, destination_body_i]
    df2 = pd.DataFrame(space_distances_date2, columns=planets_and_moons, index=planets_and_moons)
    distance_for_traveller2 = df2.loc[start_body_i, destination_body_i]
    df3 = pd.DataFrame(space_distances_date3, columns=planets_and_moons, index=planets_and_moons)
    distance_for_traveller3 = df3.loc[start_body_i, destination_body_i]

    # Finding the shortest distance of travel

    travel_dates = [distance_for_traveller1, distance_for_traveller2, distance_for_traveller3]

    shortest_travel_distance = min(travel_dates)
    
    # The day that the shortest travel distance is possible

    shortest_travel_date = travel_dates.index(shortest_travel_distance)

    # Total travel time based on average speed of 0.001AU/m

    time_total = shortest_travel_distance / 0.001


= B =

I adjusted the code so that when it sends messages back to the station for refueling, there will be 4 digit accuracy for the refueling output distances.

 df_t = open('message_to_stations3.txt', 'w')
    df_t.write('my trip starts at')
    df_t.write(start_location)
    df_t.write('and ends at')
    df_t.write(destination_location)
    df_t.write('I will need to encounter stations for \n a refueling at \n')
    for x in range(1, refuel_stops):
        y = round(0.65*x, 4)
        df_t.write(str(y))
        df_t.write('AU')
        df_t.write('\n')
    df_t.close()

= C = 

I tested that these changes in my function were succesful by calling the code for a trip starting at Earth and ending at Neptune. It returned the results:

"The distance from Earth to Neptune is 28.861 AU and occurs on day 3!
This trip will take 3 years 107 days, 13 hours, and 0 minutes.
You will require 45 refuelling stops!"

=== Problem 6 ===

= A = 

I updated the function to include an if/else loop statement that asks the user if they would like to take a grand tour (Y or N).  If no, the code runs the function that has been coded up to this point.  If the user choses Y, the else statement runs the code for the Grand Tour.


    gt = input('Do you wanna take a grand tour, input Y for yes or N for no.')

    for x in gt:
        if x == 'N':
            break
        elif x == 'Y':

            print('You have chosen to take a GRAND TOUR!')

***** OUT: Sat Feb 26 23:14:51 EST 2022

***** IN: Sun Feb 27 10:16:32 EST 2022

=== Problem 6 ===

Trouble 

***** OUT: Sun Feb 27 14:32:08 EST 2022

***** IN: Mon Feb 28 13:45:29 EST 2022

=== Problem 6 ===

= A1, A2, A3 = 

I wrote a code into my function that combined all three data frames into one data frame, then made a key corresponding to each of the initial data frames.  The key values I wrote are corresponding to the index value of the shortest date. 
The data frame got the column of the start destination, and it shortened that column to end with the ending destination.  
From the shortened column, all the possible values of stops between two planets excluding the min value zero. 
From here, it is possible then to call the shortest stop and the name of the stop. 

shortest_travel_column = [df1, df2, df3]

            result = pd.concat(shortest_travel_column, keys=['0', '1', '2'])
            df_index_shortest = str(shortest_travel_date)

            df_shortest = result.loc[df_index_shortest]

            col_df_shortest = pd.DataFrame(df_shortest[start_body_i])

            col_df_shortest_range_1 = pd.DataFrame(col_df_shortest[: start_body_i])
            col_df_shortest_range_2 = pd.DataFrame(col_df_shortest[start_body_i:])

            if destination_body_i in col_df_shortest_range_1.index:
                col_df_shortest_range_act = col_df_shortest_range_1
            else:
                col_df_shortest_range_act = col_df_shortest_range_2

            col_df_shortest_range_act_c = col_df_shortest_range_act.drop(destination_body_i)

            col_df_shortest_range_act_c_sort = col_df_shortest_range_act_c.sort_values(start_body_i)

            # col_df_shortest_range = pd.DataFrame(col_df_shortest[: destination_body_i])

            zz_top = col_df_shortest_range_act_c_sort[start_body_i].loc[col_df_shortest_range_act_c_sort[start_body_i] != 0]
            # zz_top =col_df_shortest_range[start_body_i].loc[col_df_shortest_range[start_body_i] != 0]

            shortest_stop_name = zz_top.idxmin()
            shortest_stop_dist = zz_top.min()
            # shortest_stop_nm = zz_top.idxmin()
            # shortest_stop_dist = zz_top.min()

            print('Your shortest detour stop is', shortest_stop_name, 'with a distance of', shortest_stop_dist, 'AU')

            stop_to_dest = df_shortest.loc[shortest_stop_name, destination_body_i]

            print('The distance from the extra stop to the final destination is', stop_to_dest, 'AU')

= B =

I then called GrandTour for a trip between Mars and Ceres with a stop at Mercury.  The function returned:

Do you wanna take a grand tour, input Y for yes or N for no.Y
You have chosen to take a GRAND TOUR!
Your shortest travel distance without a detour stop is 4.1647 AU from Mars to Ceres and occurs on day 1 .
Your shortest detour stop is Mercury with a distance of 1.3 AU.
The distance from the extra stop to the final destination is 2.9058 AU.
You will have a total distance of  4.2058 AU.
You will require 7 refueling stops for a GRAND TOUR!

= C = 

I created a dictionary out of the possible detour stops of the trip.  It allows the user to choose what detour stop they want, and then prints out the information regarding the start location, destination location, and refuellling dates.

I then called the function planet_tour6 for a trip from Mars to Ceres, and it returned the results:

Do you wanna take a grand tour, input Y for yes or N for no.Y
You have chosen to take a GRAND TOUR!
You will travel 4.1647 AU from Mars to Ceres and occurs on day 1
Your shortest detour stop is Mercury with a distance of 1.3 AU
The distance from the extra stop to the final destination is 2.9058 AU
You will have a total distance of  4.2058 AU
The possible stops are Mercury_1 for date_1, Mercury_2 for date_2, and, Venus for date_3
{'Mercury_1': 4.2058, 'Mercury_2': 4.5132, 'Venus': 4.5077}
You will require 7 refueling stops for a GRAND TOUR!

=== Problem 7 ===

I copied my finalized jupyter notebook to my handin_midterm_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

midterm_CSmith_Problem7_Screenshot3.png

I copied this log into my PHZ3150_handin_hw7_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Midterm Answers

***** OUT: Sun Feb 27 21:44:11 EST 2022

***** IN: Wed Mar 2 11:31:08 EST 2022

Midterm Project Answers 

=== Problem 1 ===

I created a new folder named Midterm_CSmith:
PHZ3150_Midterm_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I imported numpy as np
I imported math 
I imported pandas as pd 
I imported sys 

=== Problem 2 ===

= A = 

I created input codes for the starting location and destination locations, including an informative statement. 

start_location = input('Which location are you starting?')
destination_location = input('Which location are you arriving?')

= B =

I created a list named:

planets_and_moons

It was populated with ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']

= C = 

I wrote a code that checks for the validity of the start location and destination location that includes an informative statement that allows traveller to proceed if they pick a valid choice, or prompts the traveller to choose from the planets_and_moons list.

for start in planets_and_moons:
    if start_location == planets_and_moons:
        print(start_location, "is an allowed starting location, please proceed!")
    if start_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
        start_location = input( "Please select a valid starting location")

for finish in planets_and_moons:
    if destination_location == planets_and_moons:
        print(destination_location, 'is an allowed destination please proceed!')
    if destination_location not in planets_and_moons:
        print("Sorry", destination_location, "is not a valid destination location. Please choose from the following available starting locations", planets_and_moons)
        destination_location = input("Please select a valid destination location")

= D1 = 

I tested this function by inputting the start location "Desmos" and destination location "Io".

This returned the following results:

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot1.png

= D2 = 

I then followed the code prompts to pick the starting location "Jupiter" ,and recieved the following response:

I received the answer "Jupiter is a valid starting location, please proceed!"

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot2.png

= Bonus =

I used a while true loop to loop through correct input start and destination locations, with an if/not loop for incorrect locations.  If continued invalid locations are entered it continues to input prompt for valid locations.  If the correct location is entered, the loop breaks and informs the user that the location chosen is valid. 

while True:
    start_location = input('Which location are you starting?')
    destination_location = input('Which location are you arriving?')
    planets_and_moons = ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']
    
    if start_location and destination_location in planets_and_moons:
        print(start_location, 'is an allowed destination please proceed!', destination_location, 'is an allowed destination please proceed!')
        break
    if start_location and destination_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
       
    
    continue 

=== Problem 3 ===

= A =

I used numpy to read the data from space_distances_date1:

space_distances_date1 = np.loadtxt('../demos/solar_system_date_1.dat')

= B =

I used pandas to index the data, and assigned the index start_body_i for start_location, and the index destination_body_i for destination_location:

df = pd.DataFrame(space_distances_date1, columns = planets_and_moons, index = planets_and_moons)
start_body_i = start_location
destination_body_i = destination_location
distance_for_traveller = df.loc[start_body_i, destination_body_i]

= C =
The travel distanes towards the destination were extracted from each of the three data frames.

I printed the distance for space_distance_date1 starting at Jupiter and ending at Io using the code:

distance_for_traveller = df.loc[start_body_i, destination_body_i]

"You will travel 0.0029 AU if you start from Jupiter and arrive at Io!"

= D = 

I wrote a code that determines the time in years, days, hours, and minutes that the trip will take:

time_total = distance_for_traveller / 0.001 AU/hr

time_years = int((time_total / 24)*(1/365))
d = (((time_total/365)-time_years)*365)/24
time_days = int(d)
h = (d-time_days)*24
time_hours = int(h)
m = (h-time_hours)*60
time_minutes = int(m)

print("Your trip will take,", time_years, "years,", time_days, "days,", time_hours, "hours, and", time_minutes, "minutes")

This code for the trip from Jupiter to Io returned the result:

Your trip will take, 0 years, 0 days, 2 hours, and 53 minutes

= E = 

I created a function planet_tour saved in a seperate file planet_tour_function.py that takes the input destination and output destination and returns the travel distance and travel time in years, days, hours, and minutes. 

= F = 

I imported the planet_tour function and ran it for a starting location of Earth and a destination location of Mars. It returned:

"The distance from Earth to Mars is 2.113 AU and this trip will take 0 years, 88 days, 1 hour, and 0 minutes. 

=== Problem 4 === 

= A = 

I made the changes to my function planet_tour to include a code that checks for how many stops this trip needs to make to refuel, assuming that the ship's tank is completely full when departing, adnt that refueling is required every 0.65AU.

refuel_stops = int(math.ceil(distance_for_traveller * (1 / 0.65)))

I imported the updated planet_tour function, and ran the code for a trip from Earth to Mars:

"The distance from Earth to Mars is 2.113 AU and this trip will take 0 years 88 days, 1 hours, and 0 minutes

You will require 4 refuelling stops"

= B = 

I updated the function to include code that will write a file messages_to_stations.txt to inform the station the start location, destination location, and at what fueling stations they will be stopping (0.65AU, 1.3AU, 1.95AU).
 
= C = 

I imported the function planet_tour and ran the code for trips: 1) Io to Jupiter, and 2) Earth to Venus, and this returned:

1) The distance from Io to Jupiter is 0.0029 AU.
   This trip will take 0 years 0 days, 2 hours, and 53 minutes
   You will require 1 refuelling stops

For this trip I renamed the output messages to message_to_stations_1.txt:

# df_t = open('message_to_stations_1.txt', 'w')
#df_t.write('my trip starts at')
#df_t.write(start_location)
#df_t.write('and ends at')
#df_t.write(destination_location)
#df_t.write('I will need to encounter stations for \n a refueling at \n')
#for x in range(1, refuel_stops):
#y = 0.65*x
#df_t.write(str(y))
#df_t.write('AU')
#df_t.write('\n')
#df_t.close()

2)The distance from Earth to Venus is 0.3915 AU. 
  This trip will take 0 years 16 days, 7 hours, and 30 minutes
  You will require 1 refuelling stops

I renamed the output message to message_to_stations_2.txt.  

# df_t = open('message_to_stations_2.txt', 'w')
#df_t.write('my trip starts at')
#df_t.write(start_location)
#df_t.write('and ends at')
#df_t.write(destination_location)
#df_t.write('I will need to encounter stations for \n a refueling at \n')
#for x in range(1, refuel_stops):
#y = 0.65*x
#df_t.write(str(y))
#df_t.write('AU')
#df_t.write('\n')
#df_t.close()

I only have one message in the file, as I didnt append the message and because I kept it in write mode, the new text overwrote the previous message. 

=== Problem 5 ===

= A = 

I wrote a code in my function planet_tour that determines the shortest travel distance according to the day chosen to travel. 
I did this by making a list of the travellers distances, then called for the shortest distance using a min command.  After I had the min distance, I called for the date index that contained that distance.    
I was then able to calculate the time using the shortest distance of travel, using the same average speed as above 0.001 AU/hr.

    df1 = pd.DataFrame(space_distance_data1, columns=planets_and_moons, index=planets_and_moons)
    distance_for_traveller1 = df1.loc[start_body_i, destination_body_i]
    df2 = pd.DataFrame(space_distances_date2, columns=planets_and_moons, index=planets_and_moons)
    distance_for_traveller2 = df2.loc[start_body_i, destination_body_i]
    df3 = pd.DataFrame(space_distances_date3, columns=planets_and_moons, index=planets_and_moons)
    distance_for_traveller3 = df3.loc[start_body_i, destination_body_i]

    # Finding the shortest distance of travel

    travel_dates = [distance_for_traveller1, distance_for_traveller2, distance_for_traveller3]

    shortest_travel_distance = min(travel_dates)
    
    # The day that the shortest travel distance is possible

    shortest_travel_date = travel_dates.index(shortest_travel_distance)

    # Total travel time based on average speed of 0.001AU/hr

    time_total = shortest_travel_distance / 0.001

= B =

I adjusted the code so that when it sends messages back to the station for refueling, there will be 4 digit accuracy for the refueling output distances.

 df_t = open('message_to_stations_2.txt', 'w')
    df_t.write('my trip starts at')
    df_t.write(start_location)
    df_t.write('and ends at')
    df_t.write(destination_location)
    df_t.write('I will need to encounter stations for \n a refueling at \n')
    for x in range(1, refuel_stops):
        y = round(0.65*x, 4)
        df_t.write(str(y))
        df_t.write('AU')
        df_t.write('\n')
    df_t.close()

= C = 

I tested that these changes in my function planet_tour were succesful by calling the code for a trip starting at Earth and ending at Neptune. It returned the results:

"The distance from Earth to Neptune is 28.861 AU and occurs on day 3!
This trip will take 3 years 107 days, 13 hours, and 0 minutes.
You will require 45 refuelling stops!"

I renamed the output messages to message_to_stations_3.txt, 

#--->>>df_t = open('message_to_stations_3.txt', 'w')
#df_t.write('my trip starts at')
#df_t.write(start_location)
#df_t.write('and ends at')
#df_t.write(destination_location)
#df_t.write('I will need to encounter stations for \n a refueling at \n')
#for x in range(1, refuel_stops):
#y = round(0.65*x, 4)
#df_t.write(str(y))
#df_t.write('AU')
#df_t.write('\n')
#df_t.close()

I saved these output messages to my Handin_Midterm_CSmith folder, named as message_to_stations_3.txt

=== Problem 6 ===

This question gave me quite a bit of trouble because of the method I used to index my data (using data frames), and in hindsight, I wouldve had an easier time with less voluminous and convoluted code using a different indexing method.  

= A1, A2, A3 = 

Preparing to compare the shortest travel with respect to each of the travel dates. This object is a list.
shortest_travel_column = [df1, df2, df3]

I wrote a code to ask the user if they wanted to start a GRAND TOUR:
#gt = input('Do you wanna take a grand tour, input Y for yes or N for no.')

    #for x in gt:
        #if x == 'N':
            #break
        #elif x == 'Y':

            #print('You have chosen to take a GRAND TOUR!')

To get each of the data frames:
df_td_1 = result.loc['0']
df_td_2 = result.loc['1']
df_td_3 = result.loc['2']

Done to get the shortest distance and the celestial object name:
shortest_stop_name = zz_top.idxmin()
shortest_stop_dist = zz_top.min()

The list was was converted to a data frame with all three of the data being merged into one data frame. Three keys were assigned to each of the data frames. Because the dataframe was that contained the shortest travel was retrieved by the variable shortest_travel_date, this is why those particular keys were chosen.
result = pd.concat(shortest_travel_column, keys=['0', '1', '2'])

Here, I converted the integer to a string. This was done so that result.loc could be used.
df_index_shortest = str(shortest_travel_date)


Here, the data frame for the shotest travel was retrieved:
df_shortest = result.loc[df_index_shortest]

Here, this was to get each of the data frames for Question 6 part C:
df_td_1 = result.loc['0']
df_td_2 = result.loc['1']
df_td_3 = result.loc['2']

This data frame gives the column of the starting location that has the shortest stop:
col_df_shortest = pd.DataFrame(df_shortest[start_body_i])

These variables were included to get the column of the starting location of each of the data frame dates:
col_df_td_1 = pd.DataFrame(df_td_1[start_body_i])
col_df_td_2 = pd.DataFrame(df_td_2[start_body_i])
col_df_td_3 = pd.DataFrame(df_td_3[start_body_i])

This splits the column of the starting point into two parts. Going towards the Sun, and going away from the sun. This was done because the shortest stop would have to be in the direction of the final destination. The shortest distances get a bit more problamatic for the space objects that are closer to the sun:
col_df_shortest_range_1 = pd.DataFrame(col_df_shortest[: start_body_i])
col_df_shortest_range_2 = pd.DataFrame(col_df_shortest[start_body_i :])

This splits the column of the starting point into two parts. Going towards the Sun, and going away from the sun. This was done because the shortest stop would have to be in the direction of the final destination. The shortest distances get a bit more problamatic for the space objects that are closer to the sun. This is done for each of the data frame columns regarding to problem 6 part C:
col_df_td_1_range_1 = pd.DataFrame(col_df_td_1[: start_body_i])
col_df_td_1_range_2 = pd.DataFrame(col_df_td_1[start_body_i :])

col_df_td_2_range_1 = pd.DataFrame(col_df_td_2[: start_body_i])
col_df_td_2_range_2 = pd.DataFrame(col_df_td_2[start_body_i :])

col_df_td_3_range_1 = pd.DataFrame(col_df_td_3[: start_body_i])
col_df_td_3_range_2 = pd.DataFrame(col_df_td_3[start_body_i :])

This was to ensure that the final destination was in the right column.  And thus, the stop would on the way to the destination:
if destination_body_i in col_df_shortest_range_1.index:
    col_df_shortest_range_act = col_df_shortest_range_1
else:
    col_df_shortest_range_act = col_df_shortest_range_2

To ensure that the final destination was in the the right column.  And thus, the stop would on the way to the destination:
This was done for all of the three of the data frames.

if destination_body_i in col_df_td_1_range_1.index:
    col_df_td_1_range_act = col_df_td_1_range_1
else:
    col_df_td_1_range_act = col_df_td_1_range_2

if destination_body_i in col_df_td_2_range_1.index:
    col_df_td_2_range_act = col_df_td_2_range_1
else:
    col_df_td_2_range_act = col_df_td_2_range_2

if destination_body_i in col_df_td_3_range_1.index:
    col_df_td_3_range_act = col_df_td_3_range_1
else:
    col_df_td_3_range_act = col_df_td_3_range_2

col_df_shortest_range_act_c =  col_df_shortest_range_act.drop(destination_body_i)

This was done because in some cases, the shortest destination was the final destination itself. So is under the assumption that a detour was wanted:
col_df_td_1_range_act_c = col_df_td_1_range_act.drop(destination_body_i)

col_df_td_2_range_act_c = col_df_td_2_range_act.drop(destination_body_i)

col_df_td_3_range_act_c = col_df_td_3_range_act.drop(destination_body_i)

To sort the values from least to greatest.
col_df_shortest_range_act_c_sort = col_df_shortest_range_act_c.sort_values(start_body_i)

To sort the values from least to greatest, but for each of the three data frames:
col_df_td_1_range_act_c_sort = col_df_td_1_range_act_c.sort_values(start_body_i)

col_df_td_2_range_act_c_sort = col_df_td_2_range_act_c.sort_values(start_body_i)

col_df_td_3_range_act_c_sort = col_df_td_3_range_act_c.sort_values(start_body_i)

To remove the planet with a distance of zero, since this is the starting destinatin and we needed to get a minimum other than zero:
zz_top = col_df_shortest_range_act_c_sort[start_body_i].loc[ col_df_shortest_range_act_c_sort[start_body_i] !=0]
#zz_top =col_df_shortest_range[start_body_i].loc[col_df_shortest_range[start_body_i] != 0]

To remove the planet with a distance of zero, since this is the starting destinatin and we needed to get a minimum other than zero. Done for each of the three dataframes:
zz_top_1 = col_df_td_1_range_act_c_sort[start_body_i].loc[ col_df_td_1_range_act_c_sort[start_body_i] !=0]

zz_top_2 = col_df_td_2_range_act_c_sort[start_body_i].loc[ col_df_td_2_range_act_c_sort[start_body_i] !=0]

zz_top_3 = col_df_td_3_range_act_c_sort[start_body_i].loc[ col_df_td_3_range_act_c_sort[start_body_i] !=0]

To get the shortest distance and the celestial object name:
shortest_stop_name = zz_top.idxmin()
shortest_stop_dist = zz_top.min()

stop_to_dest = df_shortest.loc[shortest_stop_name, destination_body_i]
tot_dist = stop_to_dest + shortest_stop_dist

To get the distance from the stop to the final destination:
stop_to_dest_1 = df_td_1.loc[shortest_stop_name, destination_body_i]
tot_dist = stop_to_dest + shortest_stop_dist

To calculate the distance from the stop to the destination. This was applied to each of the three data frames.
stop_to_dest_1 = df_td_1.loc[shortest_stop_name_1, destination_body_i]
tot_dist_1 = stop_to_dest_1 + shortest_stop_dist_1

stop_to_dest_2 = df_td_2.loc[shortest_stop_name_2, destination_body_i]
tot_dist_2 = stop_to_dest_2 + shortest_stop_dist_2

stop_to_dest_3 = df_td_3.loc[shortest_stop_name_3, destination_body_i]
tot_dist_3 = stop_to_dest_3 + shortest_stop_dist_3

These if and elif statements were used to avoid the upcoming dictionary from failing to include a celestial body in if each of the data frames put a destination with the same name. This changes the name by tacking on a "an integer relating to that particular dataframe":
if shortest_stop_name_1 in [shortest_stop_name_2]:

    src = shortest_stop_name_1, shortest_stop_name_2
    shortest_stop_name_1 = shortest_stop_name_1 + str('_1')
    shortest_stop_name_2 = shortest_stop_name_2 + str('_2')
elif shortest_stop_name_1 in [shortest_stop_name_3]:
    src2 = shortest_stop_name_1, shortest_stop_name_3
    shortest_stop_name_1 = shortest_stop_name_1 + str('_1')
    shortest_stop_name_3 = shortest_stop_name_3 + str('_3')
elif shortest_stop_name_2 in [shortest_stop_name_3]:
    src3 = shortest_stop_name_2, shortest_stop_name_3
    shortest_stop_name_2 = shortest_stop_name_2 + str('_2')
    shortest_stop_name_3 = shortest_stop_name_3 + str('_3')
else:
    shortest_stop_name_1 = shortest_stop_name_1
    shortest_stop_name_2 = shortest_stop_name_2
    shortest_stop_name_3 = shortest_stop_name_3

print('The possible stops are', shortest_stop_name_1, 'for date_1,', shortest_stop_name_2, 'for date_2, and,', shortest_stop_name_3, 'for date_3')
my_dict = {shortest_stop_name_1 : tot_dist_1,  shortest_stop_name_2 :  tot_dist_2,  shortest_stop_name_3 :  tot_dist_3}

= B =

I updated the function planet_tour to inform the user of the possible stops, what dates the stops were available, the milage added, and the number of refuelling stops required.

            #Stop Mercury1 refuel 
            #refuel_stops = int(math.ceil(shortest_travel_distance * (1 / 0.65)))
            #refuel_extra_stop = int(math.ceil(shortest_stop_dist_1 * (1 / 0.65)))
            #refuel_stop_dest = int(math.ceil(stop_to_dest * (1 / 0.65)))
            
            #refuel_grand_tour1 = refuel_stop_dest + refuel_extra_stop
            
            #Stop Mercury2 refuel 
            #refuel_stops = int(math.ceil(shortest_travel_distance * (1 / 0.65)))
            #refuel_extra_stop = int(math.ceil(shortest_stop_dist_2 * (1 / 0.65)))
            #refuel_stop_dest = int(math.ceil(stop_to_dest * (1 / 0.65)))
            
            #refuel_grand_tour2 = refuel_stop_dest + refuel_extra_stop
            
            #Stop Venus3 refuel 
            #refuel_stops = int(math.ceil(shortest_travel_distance * (1 / 0.65)))
            #refuel_extra_stop = int(math.ceil(shortest_stop_dist_3 * (1 / 0.65)))
            #refuel_stop_dest = int(math.ceil(stop_to_dest * (1 / 0.65)))
            
            #refuel_grand_tour3 = refuel_stop_dest + refuel_extra_stop
            
            #print("You will require", refuel_grand_tour, "refuelling stops for a GRAND TOUR!")
            
            #print(shortest_stop_name_1, "will add", shortest_stop_dist_1, "AU to your trip, and require", refuel_grand_tour1, "refuelling stops.")
            #print(shortest_stop_name_2, "will add", shortest_stop_dist_2, " AU to your trip, and require", refuel_grand_tour2, "refuelling stops.")
            #print(shortest_stop_name_3, "will add", shortest_stop_dist_13, "AU to your trip, and require", refuel_grand_tour3, "refuelling stops.")
          

I then called GrandTour for a trip between Mars and Ceres with a stop at Mercury.  The function returned:

Do you wanna take a grand tour, input Y for yes or N for no.Y
You have chosen to take a GRAND TOUR!
The possible stops are Mercury_1 for date_1, Mercury_2 for date_2, and, Venus for date_3
The stop Mercury_1 will add 1.3 AU to your trip, and require 7 refuelling stops.
The stop Mercury_2 will add 1.5693  AU to your trip, and require 8 refuelling stops.
The stop Venus will add 0.985 AU to your trip, and require 7 refuelling stops.

**** BUG NOTE ****
I have a bug in my code that if the user choose to take the grand tour, if would print out the information for the grand tour but also the information if you didnt wish to take the grand tour. I solved this inital bug with a the sys.exit() command. It does not effect how my code runs, but it does print the warning/error:

"An exception has occurred, use %tb to see the full traceback.
SystemExit
C:\Users\3daye\miniconda3\lib\site-packages\IPython\core\interactiveshell.py:3452: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
  warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)"

I did not have time to go back and address this issue with the code. 

= C = 

The user can input which of the chosen available stops they would like, and the function returns the date, milage, and refuelling stops required, while sending a message to the station with the refuelling stop information. 

To achieve this I created a dictionary of the possible stops, and functions for the refuelling stops necessary for each of the stops.  
I then used an if/elif loop to return the information of the stop depending on the input:

            stop_choice = input("What stop would you like to choose for your trip?")
            
            if stop_choice == shortest_stop_name_1:
                print("You've chosen", shortest_stop_name_1, "as your stop. The best day is date 1 to travel to this stop. You will require", refuel_grand_tour1, "refuelling stops.")
            elif stop_choice == shortest_stop_name_2:
                print("You've chosen", shortest_stop_name_2, "as your stop. The best day is date 2 to travel to this stop. You will require", refuel_grand_tour2, "refuelling stops.")
            elif stop_choice == shortest_stop_name_3:
                print("You've chosen", shortest_stop_name_3, "as your stop. The best day is date 3 to travel to this stop. You will require", refuel_grand_tour3, "refuelling stops.")

In order to return the dates at which each of the stops occurs in the message to the station, I wrote an if loop to determine which date the user will be travelling for the stop they chose, then calculated the total time in days divided by the total refuelling stops to determine the total time in days before encountering each fuel station. 

The code for the messages sent to the station:

Done to calculate numbers of days between each fuel stop to include in message to station:
            #z = np.round(((0.65 / 0.001) / 24 ) , 3)
            z = [27.083]
            for i in range( 0, 11):
                z.append( z[i] + 27.083)
                
Sending information back to station in message_to_stations_stops.txt:
                
            df_t = open('message_to_stations_stops.txt', 'w')
            df_t.write(' Beginning at the location ')
            df_t.write(start_body_i)
            df_t.write(' and ending at ')
            df_t.write(destination_body_i)
            df_t.write(', and this is the refuelling information for my trip which starts on day ')
            df_t.write(d)
            df_t.write('. I will need to encounter stations for refueling at \n')
            for x in range(1, refuel_grand_tour):
                y = round(0.65 * x, 4)
                z = np.round(z, 3)
                df_t.write('We will refuel on date ')
                df_t.write(str(d))
                df_t.write(' + ')
                df_t.write(str(z))
                df_t.write(' days at the location ')
                df_t.write(str(y))
                df_t.write(' AU ')
                df_t.write('\n')
            df_t.close()
            sys.exit()

**** BUG NOTE**** 
This was supposed to return the information in the format:
Beginning at the location Mars and ending at Ceres. Refuelling information for my trip which starts on day 3. I will need to encounter stations for refueling at 
We will refuel on date 3 + 27.083 days at the location 0.65 AU

However, I have a bug in this code and it returned all the values for the increasing day values with each entry instead:

Beginning at the location Mars and ending at Ceres. Refuelling information for my trip which starts on day 3. I will need to encounter stations for refueling at 
We will refuel on date 3 + [ 27.083  54.166  81.249 108.332 135.415 162.498 189.581 216.664 243.747

I ran out of time to address this issue and fix the bug. 

**** NAME CHANGE NOTE **** 
If you don't change the names of Mercury_1 and Mercury_2 to account for the duplicate stops on different days, the dictionary will overwrite the first Mercury_1 value when you call for Mercury and will return the Mercury_2 values. 

I then called the function planet_tour for a trip from Mars to Ceres, and it returned the results:

Do you wanna take a grand tour, input Y for yes or N for no.Y
You have chosen to take a GRAND TOUR!
The possible stops are Mercury_1 for date_1, Mercury_2 for date_2, and, Venus for date_3
The stop Mercury_1 will add 1.3 AU to your trip, and require 7 refuelling stops.
The stop Mercury_2 will add 1.5693  AU to your trip, and require 8 refuelling stops.
The stop Venus will add 0.985 AU to your trip, and require 7 refuelling stops.
What stop would you like to choose for your trip?Mercury_1
You've chosen Mercury_1 as your stop. The best day is date 1 to travel to this stop. You will require 7 refuelling stops.

**** BUG NOTE **** 
As with Q6B, I encountered the same bug with my sys.exit() command. It does not effect how my code runs, but it does print the warning/error:

"An exception has occurred, use %tb to see the full traceback.
SystemExit
C:\Users\3daye\miniconda3\lib\site-packages\IPython\core\interactiveshell.py:3452: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
  warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)"

=== Problem 7 ===

I copied my finalized jupyter notebook to my handin_midterm_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

midterm_CSmith_Problem7_Screenshot3.png

I copied this log into my PHZ3150_handin_hw7_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Midterm Answers

***** OUT: Wed Mar 2 19:02:17 EST 2022

***** IN: Thurs Mar 3 12:37:54 EST 2022

Midterm Project Answers 

=== Problem 1 ===

I created a new folder named Midterm_CSmith:
PHZ3150_Midterm_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I imported numpy as np
I imported math 
I imported pandas as pd 
I imported sys 

=== Problem 2 ===

= A = 

I created input codes for the starting location and destination locations, including an informative statement:
start_location = input('Which location are you starting?')
destination_location = input('Which location are you arriving?')

= B =

I created a list named:
planets_and_moons

It was populated with ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']

= C = 

I wrote a code that checks for the validity of the start location and destination location that includes an informative statement that allows traveller to proceed if they pick a valid choice, or prompts the traveller to choose from the planets_and_moons list.

for start in planets_and_moons:
    if start_location == planets_and_moons:
        print(start_location, "is an allowed starting location, please proceed!")
    if start_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
        start_location = input( "Please select a valid starting location")

for finish in planets_and_moons:
    if destination_location == planets_and_moons:
        print(destination_location, 'is an allowed destination please proceed!')
    if destination_location not in planets_and_moons:
        print("Sorry", destination_location, "is not a valid destination location. Please choose from the following available starting locations", planets_and_moons)
        destination_location = input("Please select a valid destination location")

**** BONUS PROBLEM NOTE AND CODE ****

I used a while true loop to loop through correct input start and destination locations, with an if/not loop for incorrect locations.  If continued invalid locations are entered it continues to input prompt for valid locations.  If the correct location is entered, the loop breaks and informs the user that the location chosen is valid. 

while True:
    start_location = input('Which location are you starting?')
    destination_location = input('Which location are you arriving?')
    planets_and_moons = ['Mercury', 'Venus', 'Earth', 'Moon', 'Ceres', 'Mars', 'Jupiter', 'Io', 'Europa', 'Saturn', 'Titan', 'Neptune', 'Pluto', 'Charon']
    
    if start_location and destination_location in planets_and_moons:
        print(start_location, 'is an allowed destination please proceed!', destination_location, 'is an allowed destination please proceed!')
        break
    if start_location and destination_location not in planets_and_moons:
        print("Sorry",start_location,"is not a valid starting location. Please choose from the following available starting locations",planets_and_moons)
      
    continue 

= D1 = 

I tested this function by inputting the start location "Desmos" and destination location "Io".

This returned the following results:

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot1.png

= D2 = 

I then followed the code prompts to pick the starting location "Jupiter" ,and recieved the following response:

I received the answer "Jupiter is a valid starting location, please proceed!"

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem2_Screenshot2.png

=== Problem 3 ===

= A =

I used numpy to read the data from space_distances_date1:
space_distances_date1 = np.loadtxt('../demos/solar_system_date_1.dat')

= B =

I used pandas to index the data, and assigned the index start_body_i for start_location, and the index destination_body_i for destination_location:
df = pd.DataFrame(space_distances_date1, columns = planets_and_moons, index = planets_and_moons)
start_body_i = start_location
destination_body_i = destination_location
distance_for_traveller = df.loc[start_body_i, destination_body_i]

= C =

The travel distances towards the destination were extracted from each of the three data frames.

I printed the distance for space_distance_date1 starting at Jupiter and ending at Io using the code:
distance_for_traveller = df.loc[start_body_i, destination_body_i]

"You will travel 0.0029 AU if you start from Jupiter and arrive at Io!"

= D = 

I wrote a code that determines the time in years, days, hours, and minutes that the trip will take:
time_total = distance_for_traveller / 0.001 AU/hr
time_years = int((time_total / 24)*(1/365))
d = (((time_total/365)-time_years)*365)/24
time_days = int(d)
h = (d-time_days)*24
time_hours = int(h)
m = (h-time_hours)*60
time_minutes = int(m)

print("Your trip will take,", time_years, "years,", time_days, "days,", time_hours, "hours, and", time_minutes, "minutes")

This code for the trip from Jupiter to Io returned the result:
"Your trip will take, 0 Earth years, 0 Earth days, 2 Earth hours, and 53 Earth minutes."

= E = 

I created a function planet_tour saved in a seperate file planet_tour_function.py that takes the input destination and output destination and returns the travel distance and travel time in Earth years, Earth days, Earth hours, and Earth minutes. 

= F = 

I imported the planet_tour function and ran it for a starting location of Earth and a destination location of Mars. It returned:
"The distance from Earth to Mars is 2.113 AU and this trip will take 0 Earth years, 88 Earth days, 1 Earth hour, and 0 Earth minutes. 

=== Problem 4 === 

= A = 

I made the changes to my function planet_tour to include a code that checks for how many stops this trip needs to make to refuel, assuming that the ship's tank is completely full when departing, and that refueling is required every 0.65AU:
refuel_stops = int(math.ceil(distance_for_traveller * (1 / 0.65)))

I imported the updated planet_tour function, and ran the code for a trip from Earth to Mars:
"The distance from Earth to Mars is 2.113 AU and this trip will take 0 Earth years, 88 Earth days, 1 Earth hours, and 0 Earth minutes!
You will require 4 refuelling stops!"

= B = 

I updated the function to include code that will write a file messages_to_stations.txt to inform the station the start location, destination location, and at what fueling stations they will be stopping (0.65AU, 1.3AU, 1.95AU):
df_t = open('message_to_stations.txt', 'w')
df_t.write('my trip starts at')
df_t.write(start_location)
df_t.write('and ends at')
df_t.write(destination_location)
df_t.write('I will need to encounter stations for \n a refueling at \n')
for x in range(1, refuel_stops):
y = 0.65*x
df_t.write(str(y))
df_t.write('AU')
df_t.write('\n')
df_t.close()
 
= C = 

I imported the function planet_tour and ran the code for trips: 1) Io to Jupiter, 2) Earth to Venus, and 3) Earth to Pluto, this returned:

1)The distance from Io to Jupiter is 0.0029 AU.
  This trip will take 0 Earth years, 0 Earth days, 2 Earth hours, and 53 Earth minutes
  You will require 1 refuelling stops!

For this trip I renamed the output messages to message_to_stations_1.txt:
df_t = open('message_to_stations_1.txt', 'w')
df_t.write('my trip starts at')
df_t.write(start_location)
df_t.write('and ends at')
df_t.write(destination_location)
df_t.write('I will need to encounter stations for \n a refueling at \n')
for x in range(1, refuel_stops):
y = 0.65*x
df_t.write(str(y))
df_t.write('AU')
df_t.write('\n')
df_t.close()

2)The distance from Earth to Venus is 0.3915 AU. 
  This trip will take 0 Earth years, 16 Earth days, 7 Earth hours, and 30 Earth minutes
  You will require 1 refuelling stops!

For this trip I renamed the output messages to message_to_stations_1.txt:
df_t = open('message_to_stations_1.txt', 'w')
df_t.write('my trip starts at')
df_t.write(start_location)
df_t.write('and ends at')
df_t.write(destination_location)
df_t.write('I will need to encounter stations for \n a refueling at \n')
for x in range(1, refuel_stops):
y = 0.65*x
df_t.write(str(y))
df_t.write('AU')
df_t.write('\n')
df_t.close()

**** FILE NOTE ****
I only have one message in the file, as I didnt append the message and because I kept it in write mode in the same file, the new text overwrote the previous message. 

3)The distance from Earth to Pluto is 34.411 AU. 
  This trip will take 3 Earth years, 338 Earth days, 19 Earth hours, and 0 Earth minutes
  You will require 53 refuelling stops!

I renamed the output message to message_to_stations_2.txt.  
df_t = open('message_to_stations_2.txt', 'w')
df_t.write('my trip starts at')
df_t.write(start_location)
df_t.write('and ends at')
df_t.write(destination_location)
df_t.write('I will need to encounter stations for \n a refueling at \n')
for x in range(1, refuel_stops):
y = 0.65*x
df_t.write(str(y))
df_t.write('AU')
df_t.write('\n')
df_t.close()

=== Problem 5 ===

= A = 

I wrote a code in my function planet_tour that determines the shortest travel distance according to the day chosen to travel. 
I did this by making a list of the travellers distances, then called for the shortest distance using a min command.  After I had the min distance, I called for the date index that contained that distance.    
I was then able to calculate the time using the shortest distance of travel, using the same average speed as above 0.001 AU/hr.

df1 = pd.DataFrame(space_distance_data1, columns=planets_and_moons, index=planets_and_moons)
distance_for_traveller1 = df1.loc[start_body_i, destination_body_i]
df2 = pd.DataFrame(space_distances_date2, columns=planets_and_moons, index=planets_and_moons)
distance_for_traveller2 = df2.loc[start_body_i, destination_body_i]
df3 = pd.DataFrame(space_distances_date3, columns=planets_and_moons, index=planets_and_moons)
distance_for_traveller3 = df3.loc[start_body_i, destination_body_i]

Finding the shortest distance of travel:
travel_dates = [distance_for_traveller1, distance_for_traveller2, distance_for_traveller3]
shortest_travel_distance = min(travel_dates)
    
Finding the day that the shortest travel distance is possible:
shortest_travel_date = travel_dates.index(shortest_travel_distance)

Total travel time based on average speed of 0.001AU/hr:
time_total = shortest_travel_distance / 0.001

= B =

I adjusted the code so that when it sends messages back to the station for refueling, there will be 4 digit accuracy for the refueling output distances.
 df_t = open('message_to_stations_2.txt', 'w')
    df_t.write('my trip starts at')
    df_t.write(start_location)
    df_t.write('and ends at')
    df_t.write(destination_location)
    df_t.write('I will need to encounter stations for \n a refueling at \n')
    for x in range(1, refuel_stops):
        y = round(0.65*x, 4)
        df_t.write(str(y))
        df_t.write('AU')
        df_t.write('\n')
    df_t.close()

**** BUG NOTE ****
The code rounds to up to 4 decimals but doesnt print 4 digits.  I had trouble writing the code in using the '%.4f' function using the df_t.write() formatting from pandas.  I ran out of time to address this bug. 

= C = 

I tested that these changes in my function planet_tour were succesful by calling the code for a trip starting at Earth and ending at Neptune. It returned the results:
"The distance from Earth to Neptune is 28.861 AU and occurs on day 3!
This trip will take 3 years 107 days, 13 hours, and 0 minutes.
You will require 45 refuelling stops!"

I renamed the output messages to message_to_stations_3.txt:
df_t = open('message_to_stations_3.txt', 'w')
df_t.write('my trip starts at')
df_t.write(start_location)
df_t.write('and ends at')
df_t.write(destination_location)
df_t.write('I will need to encounter stations for \n a refueling at \n')
for x in range(1, refuel_stops):
y = round(0.65*x, 4)
df_t.write(str(y))
df_t.write('AU')
df_t.write('\n')
df_t.close()

I saved this output message_to_stations_3.txt to my Handin_Midterm_CSmith folder, named as message_to_stations_3.txt

=== Problem 6 ===

**** NOTE ON CODE FOR PROBLEM 6 ****
This question gave me quite a bit of trouble because of the method I used to index my data (using data frames), and in hindsight, I wouldve had an easier time with less voluminous and convoluted code using a different indexing method. I ended up spending so much time coding to solve this question that I ran out of time to fix some of the bugs that cropped up before this assignment was due. 

= A1, A2, A3 = 

Preparing to compare the shortest travel with respect to each of the travel dates. This object is a list.
shortest_travel_column = [df1, df2, df3]

I wrote a code to ask the user if they wanted to start a GRAND TOUR:
gt = input('Do you wanna take a grand tour, input Y for yes or N for no.')

    for x in gt:
        if x == 'N':
            break
        elif x == 'Y':
		print('You have chosen to take a GRAND TOUR!')

To get each of the data frames:
df_td_1 = result.loc['0']
df_td_2 = result.loc['1']
df_td_3 = result.loc['2']

Done to get the shortest distance and the celestial object name:
shortest_stop_name = zz_top.idxmin()
shortest_stop_dist = zz_top.min()

The list was was converted to a data frame with all three of the data being merged into one data frame. Three keys were assigned to each of the data frames. Because the dataframe was that contained the shortest travel was retrieved by the variable shortest_travel_date, this is why those particular keys were chosen.
result = pd.concat(shortest_travel_column, keys=['0', '1', '2'])

Here, I converted the integer to a string. This was done so that result.loc could be used.
df_index_shortest = str(shortest_travel_date)


Here, the data frame for the shotest travel was retrieved:
df_shortest = result.loc[df_index_shortest]

Here, this was to get each of the data frames for Question 6 part C:
df_td_1 = result.loc['0']
df_td_2 = result.loc['1']
df_td_3 = result.loc['2']

This data frame gives the column of the starting location that has the shortest stop:
col_df_shortest = pd.DataFrame(df_shortest[start_body_i])

These variables were included to get the column of the starting location of each of the data frame dates:
col_df_td_1 = pd.DataFrame(df_td_1[start_body_i])
col_df_td_2 = pd.DataFrame(df_td_2[start_body_i])
col_df_td_3 = pd.DataFrame(df_td_3[start_body_i])

This splits the column of the starting point into two parts. Going towards the Sun, and going away from the sun. This was done because the shortest stop would have to be in the direction of the final destination. The shortest distances get a bit more problamatic for the space objects that are closer to the sun:
col_df_shortest_range_1 = pd.DataFrame(col_df_shortest[: start_body_i])
col_df_shortest_range_2 = pd.DataFrame(col_df_shortest[start_body_i :])

This splits the column of the starting point into two parts. Going towards the Sun, and going away from the sun. This was done because the shortest stop would have to be in the direction of the final destination. The shortest distances get a bit more problamatic for the space objects that are closer to the sun. This is done for each of the data frame columns regarding to problem 6 part C:
col_df_td_1_range_1 = pd.DataFrame(col_df_td_1[: start_body_i])
col_df_td_1_range_2 = pd.DataFrame(col_df_td_1[start_body_i :])

col_df_td_2_range_1 = pd.DataFrame(col_df_td_2[: start_body_i])
col_df_td_2_range_2 = pd.DataFrame(col_df_td_2[start_body_i :])

col_df_td_3_range_1 = pd.DataFrame(col_df_td_3[: start_body_i])
col_df_td_3_range_2 = pd.DataFrame(col_df_td_3[start_body_i :])

This was to ensure that the final destination was in the right column.  And thus, the stop would on the way to the destination:
if destination_body_i in col_df_shortest_range_1.index:
    col_df_shortest_range_act = col_df_shortest_range_1
else:
    col_df_shortest_range_act = col_df_shortest_range_2

To ensure that the final destination was in the the right column.  And thus, the stop would on the way to the destination:
This was done for all of the three of the data frames.

if destination_body_i in col_df_td_1_range_1.index:
    col_df_td_1_range_act = col_df_td_1_range_1
else:
    col_df_td_1_range_act = col_df_td_1_range_2

if destination_body_i in col_df_td_2_range_1.index:
    col_df_td_2_range_act = col_df_td_2_range_1
else:
    col_df_td_2_range_act = col_df_td_2_range_2

if destination_body_i in col_df_td_3_range_1.index:
    col_df_td_3_range_act = col_df_td_3_range_1
else:
    col_df_td_3_range_act = col_df_td_3_range_2

col_df_shortest_range_act_c =  col_df_shortest_range_act.drop(destination_body_i)

This was done because in some cases, the shortest destination was the final destination itself. So is under the assumption that a detour was wanted:
col_df_td_1_range_act_c = col_df_td_1_range_act.drop(destination_body_i)

col_df_td_2_range_act_c = col_df_td_2_range_act.drop(destination_body_i)

col_df_td_3_range_act_c = col_df_td_3_range_act.drop(destination_body_i)

To sort the values from least to greatest.
col_df_shortest_range_act_c_sort = col_df_shortest_range_act_c.sort_values(start_body_i)

To sort the values from least to greatest, but for each of the three data frames:
col_df_td_1_range_act_c_sort = col_df_td_1_range_act_c.sort_values(start_body_i)

col_df_td_2_range_act_c_sort = col_df_td_2_range_act_c.sort_values(start_body_i)

col_df_td_3_range_act_c_sort = col_df_td_3_range_act_c.sort_values(start_body_i)

To remove the planet with a distance of zero, since this is the starting destinatin and we needed to get a minimum other than zero:
zz_top = col_df_shortest_range_act_c_sort[start_body_i].loc[ col_df_shortest_range_act_c_sort[start_body_i] !=0]
#zz_top =col_df_shortest_range[start_body_i].loc[col_df_shortest_range[start_body_i] != 0]

To remove the planet with a distance of zero, since this is the starting destinatin and we needed to get a minimum other than zero. Done for each of the three dataframes:
zz_top_1 = col_df_td_1_range_act_c_sort[start_body_i].loc[ col_df_td_1_range_act_c_sort[start_body_i] !=0]

zz_top_2 = col_df_td_2_range_act_c_sort[start_body_i].loc[ col_df_td_2_range_act_c_sort[start_body_i] !=0]

zz_top_3 = col_df_td_3_range_act_c_sort[start_body_i].loc[ col_df_td_3_range_act_c_sort[start_body_i] !=0]

To get the shortest distance and the celestial object name:
shortest_stop_name = zz_top.idxmin()
shortest_stop_dist = zz_top.min()
stop_to_dest = df_shortest.loc[shortest_stop_name, destination_body_i]
tot_dist = stop_to_dest + shortest_stop_dist

To get the distance from the stop to the final destination:
stop_to_dest_1 = df_td_1.loc[shortest_stop_name, destination_body_i]
tot_dist = stop_to_dest + shortest_stop_dist

To calculate the distance from the stop to the destination. This was applied to each of the three data frames.
stop_to_dest_1 = df_td_1.loc[shortest_stop_name_1, destination_body_i]
tot_dist_1 = stop_to_dest_1 + shortest_stop_dist_1
stop_to_dest_2 = df_td_2.loc[shortest_stop_name_2, destination_body_i]
tot_dist_2 = stop_to_dest_2 + shortest_stop_dist_2
stop_to_dest_3 = df_td_3.loc[shortest_stop_name_3, destination_body_i]
tot_dist_3 = stop_to_dest_3 + shortest_stop_dist_3

These if and elif statements were used to avoid the upcoming dictionary from failing to include a celestial body in if each of the data frames put a destination with the same name. This changes the name by tacking on a "an integer relating to that particular dataframe":
if shortest_stop_name_1 in [shortest_stop_name_2]:
    src = shortest_stop_name_1, shortest_stop_name_2
    shortest_stop_name_1 = shortest_stop_name_1 + str('_1')
    shortest_stop_name_2 = shortest_stop_name_2 + str('_2')
elif shortest_stop_name_1 in [shortest_stop_name_3]:
    src2 = shortest_stop_name_1, shortest_stop_name_3
    shortest_stop_name_1 = shortest_stop_name_1 + str('_1')
    shortest_stop_name_3 = shortest_stop_name_3 + str('_3')
elif shortest_stop_name_2 in [shortest_stop_name_3]:
    src3 = shortest_stop_name_2, shortest_stop_name_3
    shortest_stop_name_2 = shortest_stop_name_2 + str('_2')
    shortest_stop_name_3 = shortest_stop_name_3 + str('_3')
else:
    shortest_stop_name_1 = shortest_stop_name_1
    shortest_stop_name_2 = shortest_stop_name_2
    shortest_stop_name_3 = shortest_stop_name_3

print('The possible stops are', shortest_stop_name_1, 'for date_1,', shortest_stop_name_2, 'for date_2, and,', shortest_stop_name_3, 'for date_3')
my_dict = {shortest_stop_name_1 : tot_dist_1,  shortest_stop_name_2 :  tot_dist_2,  shortest_stop_name_3 :  tot_dist_3}

= B =

I updated the function planet_tour to inform the user of the possible stops, what dates the stops were available, the milage added, and the number of refuelling stops required.

Stop Mercury1 refuel 
refuel_stops = int(math.ceil(shortest_travel_distance * (1 / 0.65)))
refuel_extra_stop = int(math.ceil(shortest_stop_dist_1 * (1 / 0.65)))
refuel_stop_dest = int(math.ceil(stop_to_dest * (1 / 0.65)))
refuel_grand_tour1 = refuel_stop_dest + refuel_extra_stop
Stop Mercury2 refuel 
refuel_stops = int(math.ceil(shortest_travel_distance * (1 / 0.65)))
refuel_extra_stop = int(math.ceil(shortest_stop_dist_2 * (1 / 0.65)))
refuel_stop_dest = int(math.ceil(stop_to_dest * (1 / 0.65)))
refuel_grand_tour2 = refuel_stop_dest + refuel_extra_stop
Stop Venus3 refuel 
refuel_stops = int(math.ceil(shortest_travel_distance * (1 / 0.65)))
refuel_extra_stop = int(math.ceil(shortest_stop_dist_3 * (1 / 0.65)))
refuel_stop_dest = int(math.ceil(stop_to_dest * (1 / 0.65)))
refuel_grand_tour3 = refuel_stop_dest + refuel_extra_stop
            
print("You will require", refuel_grand_tour, "refuelling stops for a GRAND TOUR!")
            
print(shortest_stop_name_1, "will add", shortest_stop_dist_1, "AU to your trip, and require", refuel_grand_tour1, "refuelling stops.")
print(shortest_stop_name_2, "will add", shortest_stop_dist_2, " AU to your trip, and require", refuel_grand_tour2, "refuelling stops.")
print(shortest_stop_name_3, "will add", shortest_stop_dist_13, "AU to your trip, and require", refuel_grand_tour3, "refuelling stops.")
          

I then called GrandTour for a trip between Mars and Ceres with a stop at Mercury.  The function returned:

Do you wanna take a grand tour, input Y for yes or N for no.Y
You have chosen to take a GRAND TOUR!
The possible stops are Mercury_1 for date_1, Mercury_2 for date_2, and, Venus for date_3
The stop Mercury_1 will add 1.3 AU to your trip, and require 7 refuelling stops.
The stop Mercury_2 will add 1.5693  AU to your trip, and require 8 refuelling stops.
The stop Venus will add 0.985 AU to your trip, and require 7 refuelling stops.

**** BUG NOTE ****
I have a bug in my code that if the user choose to take the grand tour, if would print out the information for the grand tour but also the information if you didnt wish to take the grand tour. I solved this inital bug with a the sys.exit() command. It does not effect how my code runs, but it does print the warning/error:

"An exception has occurred, use %tb to see the full traceback.
SystemExit
C:\Users\3daye\miniconda3\lib\site-packages\IPython\core\interactiveshell.py:3452: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
  warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)"

I did not have time to go back and address this issue with the code. 

= C = 

The user can input which of the chosen available stops they would like, and the function returns the date, milage, and refuelling stops required, while sending a message to the station with the refuelling stop information. 

To achieve this I created a dictionary of the possible stops, and functions for the refuelling stops necessary for each of the stops.  
I then used an if/elif loop to return the information of the stop depending on the input:

stop_choice = input("What stop would you like to choose for your trip?")
            
if stop_choice == shortest_stop_name_1:
	print("You've chosen", shortest_stop_name_1, "as your stop. The best day is date 1 to travel to this stop. You will require", refuel_grand_tour1, "refuelling stops.")
elif stop_choice == shortest_stop_name_2:
        print("You've chosen", shortest_stop_name_2, "as your stop. The best day is date 2 to travel to this stop. You will require", refuel_grand_tour2, "refuelling stops.")
elif stop_choice == shortest_stop_name_3:
        print("You've chosen", shortest_stop_name_3, "as your stop. The best day is date 3 to travel to this stop. You will require", refuel_grand_tour3, "refuelling stops.")

In order to return the dates at which each of the stops occurs in the message to the station, I wrote an if loop to determine which date the user will be travelling for the stop they chose, then calculated the total time in days divided by the total refuelling stops to determine the total time in days before encountering each fuel station. 

The code for the messages sent to the station:

Done to calculate numbers of days between each fuel stop to include in message to station:
z = np.round(((0.65 / 0.001) / 24 ) , 3)
z = [27.083]
for i in range( 0, 11):
	z.append( z[i] + 27.083)
                
Sending information back to station in message_to_stations_stops.txt:
df_t = open('message_to_stations_stops.txt', 'w')
df_t.write(' Beginning at the location ')
df_t.write(start_body_i)
df_t.write(' and ending at ')
df_t.write(destination_body_i)
df_t.write(', and this is the refuelling information for my trip which starts on day ')
df_t.write(d)
df_t.write('. I will need to encounter stations for refueling at \n')
for x in range(1, refuel_grand_tour):
	y = round(0.65 * x, 4)
        z = np.round(z, 3)
        df_t.write('We will refuel on date ')
        df_t.write(str(d))
        df_t.write(' + ')
        df_t.write(str(z))
        df_t.write(' days at the location ')
        df_t.write(str(y))
        df_t.write(' AU ')
        df_t.write('\n')
df_t.close()
sys.exit()

**** BUG NOTE**** 
This was supposed to return the information in the format:
Beginning at the location Mars and ending at Ceres. Refuelling information for my trip which starts on day 3. I will need to encounter stations for refueling at 
We will refuel on date 3 + 27.083 days at the location 0.65 AU

However, I have a bug in this code and it returned all the values for the increasing day values with each entry instead:

Beginning at the location Mars and ending at Ceres. Refuelling information for my trip which starts on day 3. I will need to encounter stations for refueling at 
We will refuel on date 3 + [ 27.083  54.166  81.249 108.332 135.415 162.498 189.581 216.664 243.747

I ran out of time to address this issue and fix the bug. 

**** NAME CHANGE NOTE **** 
If you don't change the names of Mercury_1 and Mercury_2 to account for the duplicate stops on different days, the dictionary will overwrite the first Mercury_1 value when you call for Mercury and will return the Mercury_2 values. 

I then called the function planet_tour for a trip from Mars to Ceres, and it returned the results:

Do you wanna take a grand tour, input Y for yes or N for no.Y
You have chosen to take a GRAND TOUR!
The possible stops are Mercury_1 for date_1, Mercury_2 for date_2, and, Venus for date_3
The stop Mercury_1 will add 1.3 AU to your trip, and require 7 refuelling stops.
The stop Mercury_2 will add 1.5693  AU to your trip, and require 8 refuelling stops.
The stop Venus will add 0.985 AU to your trip, and require 7 refuelling stops.
What stop would you like to choose for your trip?Mercury_1
You've chosen Mercury_1 as your stop. The best day is date 1 to travel to this stop. You will require 7 refuelling stops.

**** BUG NOTE **** 
As with Q6B, I encountered the same bug with my sys.exit() command. It does not effect how my code runs, but it does print the warning/error:

"An exception has occurred, use %tb to see the full traceback.
SystemExit
C:\Users\3daye\miniconda3\lib\site-packages\IPython\core\interactiveshell.py:3452: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
  warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)"

=== Problem 7 ===

I copied my finalized jupyter notebook to my handin_midterm_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

Midterm_CSmith_Problem7_Screenshot3.png

I copied this log into my PHZ3150_handin_hw7_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Midterm Answers

***** OUT: Thurs Mar 3 13:01:16 EST 2022

***** IN: Thurs Mar 10 09:14:20 EST 2022

Start of Homework 8

=== Problem 1 ===

I created a new homework folder named HW8_CSmith:
PHZ3150_Homework_HW8_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW8_CSmith,
I imported:

import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from mpl_toolkits.mplot3d import Axes3D

=== Problem 2 ===

I created a text file named HW8_support_function.py and created a function named kepler_3rd:

def kepler_3rd(planet_x, p1, p2, a1):
    """Function that gets as input the orbital period of a planet in years and returns the orbital distance of a planet to the Sun.
    Input: Planet of interest(planet_x), orbital period planet Earth(p1) days, orbital period planet x(p2) days, distane planet Earth(a1) AU
    Output: Orbital distance planet x(a2) AU"""
    
    a2 = np.cbrt((np.power(a1, 3) * np.power(p2, 2))/np.power(p1, 2))
    
    print('The distance from planet', planet_x, 'is', a2, '.')
    
    return a2 

I imported this function into my HW8_CSmith jupyter notebook, and called the function for the planets listed in my planet_x list.

It returned the values:

The distance from the planet Mercury is 1.72 AU.
The distance from the planet Venus is 4.4 AU.
The distance from the planet Mars is 13.5 AU.
The distance from the planet Jupiter is 84.8 AU.
The distance from the planet Saturn is 210.89 AU.
The distance from the planet Uranus is 600.57 AU.
The distance from the planet Neptune is 1177.96 AU.

***** OUT: Thurs Mar 10 10:31:27 EST 2022

***** IN: Tues Mar 15 11:17:38 EST 2022

=== Problem 2 ===

I plotted the actual values for the distances between planets in AU and the caluclated distances in AU between planets from the function kepler_3rd:

x = np.linspace(0., 6., 7)

fig = plt.figure( figsize = (8,8) )

ax1 = fig.add_subplot(1, 1, 1)
ax2 = ax1.twinx()

ax1.plot(x, Calculated, color= 'blue' )
ax1.set_ylabel( 'Calulated', color='blue', fontsize=24, rotation = 90 )
ax1.tick_params( axis="both", labelsize=18, length = 7 , direction = 'in' )

ax2.plot(x, Actual, color='red')
ax2.set_ylabel('Actual', color='red',fontsize=24, rotation = 90)
ax2.tick_params( axis="y", labelsize=18 , length = 7 , direction = 'in' )

ax1.set_xticklabels([' ', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'], rotation = 90)

=== Problem 3 === 

= A = 

I created the arrays:

x = np.linspace(12, 46, 100)
y = np.array((np.sin((2*np.pi*x)/16)) * (np.cos((2*np.pi*x)/8)))
z = np.array((np.cos((np.pi*x)/9)) * (np.sin((np.pi*x)/6)))

*NOTE: I checked the shape of the arrays which was not specified by the instructions in the homework to help later on in the homework when it calls to create 2D arrays the same length as theses arrays

I then plotted both X vs Y and X vs Z on the same graph:

fig = plt.figure( figsize = (8,8) )
ax1 = fig.add_subplot(1, 1, 1)
ax2 = ax1.twinx()
plt.xlim( 20, 40 )
ax1.plot( x, y, color= 'blue', linestyle = 'solid', label = 'Y')
ax1.set_ylabel( 'Y & Z', color='black', fontsize=35, rotation = 90 )
ax1.set_xlabel('x',fontsize=35)
ax1.tick_params( axis="both", labelsize=20, length = 2 , direction = 'out') 
plt.yticks( np.arange( -1.0, 2.1, step = 0.5 ) ,fontsize=35) 
plt.xticks( np.arange( 20, 40.1, 10 ) , fontsize=35)
    
ax2.plot( x, z, color='red', linestyle = '--', label = 'Z')
plt.title( 'Problem 3A' , fontsize = 35 )
plt.legend( fontsize = 35 )

plt.tick_params(labelright=False, right=False)

= B =

I scanned the arrays x,y and z and printed the elements of x and y where both y and z are positive:

for i in range(len(x)):
    if y[i] > 0 and z[i] > 0:
        print (x, y)
for j in range(len(y)):
    if z[j] > 0 and y[j] > 0:
        print(x, y)
for k in range(len(z)):
    if y[k] > 0 and z[k] > 0:
        print(x, y)

= C = 

I created 2 2D arrays and populated them with zeros:

data = np.zeros((100,100))
data12 = np.zeros((100,100))

= D = 

I used a double for loop to populate arrays data and data2 where data is equal to y[i]*z[j] and data2 is equal to y[i]/z[j]:

for i in range(len(y)):
    for j in range(len(z)):
        data = np.array(y[i]*z[j])
        data2 = np.array(y[i] / z[j])

*Note: I printed both the data and data2 array which was not specified by the homework instructions as I had a bug in my inital for loop and needed to check if the values printed from the arrays were reasonable. 

= E = 

In one line I printed z where y is positive and less than 0.4:

print(z[(y > 0) & (y < 0.4)])
 
In one line I printed data where y is positive and less than 0.2 in the x dimension and where z is negative and larger than -0.16 in the y dimension:

print(data(x[(y>0) & (y<0.2)] , y[(z < 0) & (z > -0.16)]))

= F = 

I made and and printed an array datatr which is the transpose of array data:

datatr = np.transpose(data)
print(datatr)

= G = 

I created a scatter plot of Column 2 of the datatr array vs Column 42 of data2 array:

fig, ax = plt.subplots( figsize = ( 8, 8 ) )

fig.suptitle('Col 2 datatr vs Col 42 data2', fontsize = 30)

ax.scatter( datatr, data2)
ax.set_xlabel( 'Y' , fontsize = 30 )
ax.set_ylabel( 'Z' , fontsize = 30 , rotation = 90)
ax.set_xticks( np.arange( -1.0, 1.1, 0.5) )
ax.set_xticklabels( np.arange( -1.0, 1.1, 0.5) , fontsize = 14 )
ax.tick_params( axis ='both', which ='both', length = 7 , direction = 'out' , labelsize=14 )

=== Problem 4 ===

= A = 

In the file HW8_support_function.py I created a function called piston which Calculates the pressures for the piston volumes in V, using the adiabatic law, and calculates the temperatures using the ideal gas law:

def piston(V,P0,V0,T0,gamma):
    """Calculates the pressures for the piston volumes in V, using the adiabatic law, and calculates the temperatures using the ideal gas law.
    Input: Volume(L), inital pressure (ATM), inital temperature (K), gamma 
    Output: pressure(ATM), temperature(K)"""

    const = (P0*V0)/T0
    const1 = P0*(V0**gamma)
    
    P = const1/(V**gamma)
    T = P*V/ const
              
    Piston = np.array([P, V, T])
    
    return Piston

I imported the piston function into my jupyter notebook:

from HW8_support_function import piston 

I called this function for the values:

V = np.linspace(1,0.1,40)
P0 = 1
T0 = 300
V0 = 1
gamma = 1.4
Piston = piston(V, P0, V0, T0, gamma)
print(Piston[0,:])
print(Piston[1,:])
print(Piston[2,:])

It returned a 3D array each with 40 elements (V, T, P)

= B = 

I created a 3D plot of the Piston 3D array:

fig,ax =plt.subplots(1,1, figsize =(16,16))
ax = plt.axes(projection='3d')

P = Piston[0,:]
V = Piston[1,:]
T = Piston[2,:]

ax.set_xlabel('Volume', fontsize = 25 )
ax.set_ylabel('Pressure', fontsize = 25 )
ax.set_zlabel('Temperature', fontsize = 25 )

ax = fig.gca(projection='3d')
ax.plot(P, V, T, label='Gas Volume vs Pressure vs Temperature')
ax.legend( fontsize = 25 )

plt.savefig( 'HW8_CSmith_Problem4_Plot.png', format = 'png', dpi = 1200, bbox_inches = 'tight', pad_inches = 0.3 )

I saved a copy of this plot as HW8_CSmith_Problem4_Plot.png as a PNG file.

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_HW8_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW8_CSmith_Problem5_Screenshot.png

I copied this log into my PHZ3150_handin_hw8_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 8 answers 

***** OUT: Tues Mar 15 13:11:57 EST 2022

***** IN: Thurs Mar 17 09:13:34 EST 2022

Start of Homework 8

=== Problem 1 ===

I created a new homework folder named HW8_CSmith:
PHZ3150_Homework_HW8_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW8_CSmith,
I imported:

import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from mpl_toolkits.mplot3d import Axes3D

=== Problem 2 ===

I created a text file named HW8_support_function.py and created a function named kepler_3rd:

def kepler_3rd(planet_x, p1, p2, a1):
    """Function that gets as input the orbital period of a planet in years and returns the orbital distance of a planet to the Sun.
    Input: Planet of interest(planet_x), orbital period planet Earth(p1) days, orbital period planet x(p2) days, distane planet Earth(a1) AU
    Output: Orbital distance planet x(a2) AU"""
    
    a2 = np.cbrt((np.power(a1, 3) * np.power(p2, 2))/np.power(p1, 2))
    
    print('The distance from planet', planet_x, 'is', a2, '.')
    
    return a2 

I imported this function into my HW8_CSmith jupyter notebook, and called the function for the planets listed in my planet_x list.

It returned the values:

The distance from the planet Mercury is 1.72 AU.
The distance from the planet Venus is 4.4 AU.
The distance from the planet Mars is 13.5 AU.
The distance from the planet Jupiter is 84.8 AU.
The distance from the planet Saturn is 210.89 AU.
The distance from the planet Uranus is 600.57 AU.
The distance from the planet Neptune is 1177.96 AU.

=== Problem 2 ===

I plotted the actual values for the distances between planets in AU and the caluclated distances in AU between planets from the function kepler_3rd:

x = np.linspace(0., 6., 7)

fig = plt.figure( figsize = (8,8) )

ax1 = fig.add_subplot(1, 1, 1)
ax2 = ax1.twinx()

ax1.plot(x, Calculated, color= 'blue' )
ax1.set_ylabel( 'Calulated', color='blue', fontsize=24, rotation = 90 )
ax1.tick_params( axis="both", labelsize=18, length = 7 , direction = 'in' )

ax2.plot(x, Actual, color='red')
ax2.set_ylabel('Actual', color='red',fontsize=24, rotation = 90)
ax2.tick_params( axis="y", labelsize=18 , length = 7 , direction = 'in' )

ax1.set_xticklabels([' ', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'], rotation = 90)

=== Problem 3 === 

= A = 

I created the arrays:

x = np.linspace(12, 46, 100)
y = np.array((np.sin((2*np.pi*x)/16)) * (np.cos((2*np.pi*x)/8)))
z = np.array((np.cos((np.pi*x)/9)) * (np.sin((np.pi*x)/6)))

*NOTE: I checked the shape of the arrays which was not specified by the instructions in the homework to help later on in the homework when it calls to create 2D arrays the same length as theses arrays

I then plotted both X vs Y and X vs Z on the same graph:

fig = plt.figure( figsize = (8,8) )
ax1 = fig.add_subplot(1, 1, 1)
ax2 = ax1.twinx()
plt.xlim( 20, 40 )
ax1.plot( x, y, color= 'blue', linestyle = 'solid', label = 'Y')
ax1.set_ylabel( 'Y & Z', color='black', fontsize=35, rotation = 90 )
ax1.set_xlabel('x',fontsize=35)
ax1.tick_params( axis="both", labelsize=20, length = 2 , direction = 'out') 
plt.yticks( np.arange( -1.0, 2.1, step = 0.5 ) ,fontsize=35) 
plt.xticks( np.arange( 20, 40.1, 10 ) , fontsize=35)
    
ax2.plot( x, z, color='red', linestyle = '--', label = 'Z')
plt.title( 'Problem 3A' , fontsize = 35 )
plt.legend( fontsize = 35 )

plt.tick_params(labelright=False, right=False)

= B =

I scanned the arrays x,y and z and printed the elements of x and y where both y and z are positive:

for i in range(len(x)):
    if y[i] > 0 and z[i] > 0:
        print (x, y)
for j in range(len(y)):
    if z[j] > 0 and y[j] > 0:
        print(x, y)
for k in range(len(z)):
    if y[k] > 0 and z[k] > 0:
        print(x, y)

= C = 

I created 2 2D arrays and populated them with zeros:

data = np.zeros((100,100))
data12 = np.zeros((100,100))

= D = 

I used a double for loop to populate arrays data and data2 where data is equal to y[i]*z[j] and data2 is equal to y[i]/z[j]:

for i in range(len(y)):
    for j in range(len(z)):
        data = np.array(y[i]*z[j])
        data2 = np.array(y[i] / z[j])

*Note: I printed both the data and data2 array which was not specified by the homework instructions as I had a bug in my inital for loop and needed to check if the values printed from the arrays were reasonable. 

= E = 

In one line I printed z where y is positive and less than 0.4:

print(z[(y > 0) & (y < 0.4)])
 
In one line I printed data where y is positive and less than 0.2 in the x dimension and where z is negative and larger than -0.16 in the y dimension:

print(data(x[(y>0) & (y<0.2)] , y[(z < 0) & (z > -0.16)]))

= F = 

I made and and printed an array datatr which is the transpose of array data:

datatr = np.transpose(data)
print(datatr)

= G = 

I created a scatter plot of Column 2 of the datatr array vs Column 42 of data2 array:

fig, ax = plt.subplots( figsize = ( 8, 8 ) )

fig.suptitle('Col 2 datatr vs Col 42 data2', fontsize = 30)

ax.scatter( datatr, data2)
ax.set_xlabel( 'Y' , fontsize = 30 )
ax.set_ylabel( 'Z' , fontsize = 30 , rotation = 90)
ax.set_xticks( np.arange( -1.0, 1.1, 0.5) )
ax.set_xticklabels( np.arange( -1.0, 1.1, 0.5) , fontsize = 14 )
ax.tick_params( axis ='both', which ='both', length = 7 , direction = 'out' , labelsize=14 )

***BUG NOTE 

The scatter plot shows a straight line at 0, but upon printing the col 2 of datatr and col 42 of data2, the values are very small and when plotted withe these y axis parameters appear as zero. I am unsure if this is because there is a bug in my data arrays or if this was coded correctly and how it should look. I didnt have time to really verify this before this assignment was due. 
I checked the values of col42 data2 and col 2 datatr arrays, and they do not contain a population of zeros, but very small numbers. 

=== Problem 4 ===

= A = 

In the file HW8_support_function.py I created a function called piston which Calculates the pressures for the piston volumes in V, using the adiabatic law, and calculates the temperatures using the ideal gas law:

def piston(V,P0,V0,T0,gamma):
    """Calculates the pressures for the piston volumes in V, using the adiabatic law, and calculates the temperatures using the ideal gas law.
    Input: Volume(L), inital pressure (ATM), inital temperature (K), gamma 
    Output: pressure(ATM), temperature(K)"""

    const = (P0*V0)/T0
    const1 = P0*(V0**gamma)
    
    P = const1/(V**gamma)
    T = P*V/ const
              
    Piston = np.array([P, V, T])
    
    return Piston

I imported the piston function into my jupyter notebook:

from HW8_support_function import piston 

I called this function for the values:

V = np.linspace(1,0.1,40)
P0 = 1
T0 = 300
V0 = 1
gamma = 1.4
Piston = piston(V, P0, V0, T0, gamma)
print(Piston[0,:])
print(Piston[1,:])
print(Piston[2,:])

It returned a 3D array each with 40 elements (V, T, P)

= B = 

I created a 3D plot of the Piston 3D array:

fig,ax =plt.subplots(1,1, figsize =(16,16))
ax = plt.axes(projection='3d')

P = Piston[0,:]
V = Piston[1,:]
T = Piston[2,:]

ax.set_xlabel('Volume', fontsize = 25 )
ax.set_ylabel('Pressure', fontsize = 25 )
ax.set_zlabel('Temperature', fontsize = 25 )

ax = fig.gca(projection='3d')
ax.plot(P, V, T, label='Gas Volume vs Pressure vs Temperature')
ax.legend( fontsize = 25 )

plt.savefig( 'HW8_CSmith_Problem4_Plot.png', format = 'png', dpi = 1200, bbox_inches = 'tight', pad_inches = 0.3 )

I saved a copy of this plot as HW8_CSmith_Problem4_Plot.png as a PNG file.

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_HW8_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW8_CSmith_Problem5_Screenshot.png

I copied this log into my PHZ3150_handin_hw8_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 8 answers 

***** OUT: Thurs Mar 17 10:31:65 EST 2022

***** IN: Sun Mar 20 14:39:03 EST 2022

Start of Homework 9

=== Problem 1 ===

I created a new homework folder named HW9_CSmith:
PHZ3150_Homework_HW9_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW9_CSmith,
I imported:

import numpy as np
import math
import matplotlib.pyplot as plt

I read the chapters 16,17,18 from the online textbook listed in the PHZ3150 syllabus, "thinkpython'

=== Problem 2 ===

= A =

I created a numpy array for sports:

sports = np.array([1500, 40000, 10000])

I created a numpy array for athlete times:

athlete_times = np.array([[1,1.204,6.6,0.32],[2,1.212,6.5,0.36],[3,1.14,6.6,0.38],[4,1.12,6.2,0.38],[5,1.24,5.6,0.4],[6,1.201,6.0,0.3]])

= B = 

I wrote a function that takes as input that two arrays and outputs an informative message about which participant will finish first and their expected time in hours, and which one will finish last and their expected time in hours.

def triathlon_time(sports,athlete_times):
    """Function inputs arrays sports and athlete_times and outputs an informative message about 
which participant will finish first and their expected time in hours, and which one 
will finish last and their expected time in hours.
Input: Sports(distance), athlete_times(info)
Output: participant finish(placing and times)."""
    
    sports = sports 
    athlete_times = athlete_times

    Mary_swim = athlete_times[0,1:2]
    John_swim = athlete_times[1,1:2]
    Peter_swim = athlete_times[2,1:2]
    Mafalda_swim = athlete_times[3,1:2]
    Paul_swim = athlete_times[4,1:2]
    Lionel_swim = athlete_times[5,1:2]   
    
    Mary_bike = athlete_times[0,2:3]
    John_bike = athlete_times[1,2:3]
    Peter_bike = athlete_times[2,2:3]
    Mafalda_bike = athlete_times[3,2:3]
    Paul_bike = athlete_times[4,2:3]
    Lionel_bike = athlete_times[5,2:3]

    Mary_run = athlete_times[0,3:4]
    John_run = athlete_times[1,3:4]
    Peter_run = athlete_times[2,3:4]
    Mafalda_run = athlete_times[3,3:4]
    Paul_run = athlete_times[4,3:4]
    Lionel_run = athlete_times[5,3:4]

    swim = sports[0]
    bike = sports[1]
    run = sports[2]

    Mary = ((swim/Mary_swim)+(bike/Mary_bike)+(run/Mary_run)) 
    John = ((swim/John_swim)+(bike/John_bike)+(run/John_run)) 
    Peter = ((swim/Peter_swim)+(bike/Peter_bike)+(run/Peter_run)) 
    Mafalda = ((swim/Mafalda_swim)+(bike/Mafalda_bike)+(run/Mafalda_run)) 
    Paul = ((swim/Paul_swim)+(bike/Paul_bike)+(run/Paul_run)) 
    Lionel = ((swim/Lionel_swim)+(bike/Lionel_bike)+(run/Lionel_run)) 

    total_time = np.array([Mary,John,Peter,Mafalda,Paul,Lionel])

    names = {'Mary':Mary, 'John':John, 'Peter':Peter, 'Mafalda':Mafalda, 'Paul':Paul, 'Lionel':Lionel}

    first_place_athlete = np.min(total_time)
    #print(np.where(total_time==first_place_athlete))

    first_place_hours = np.ceil(first_place_athlete / 360)

    last_place_athlete = np.max(total_time)
    #print(np.where(total_time==last_place_athlete))

    last_place_hours = np.ceil(last_place_athlete / 360)

    print("The first place athlete is Paul with the estimated time of", first_place_hours, 'hours.')
    print("The last place athlete is Lionel with the estimated time of", last_place_hours, "hours.")

= C = 

I created two dictionaries:

sports_dictionary = {'swim':1500, 'bike':40000, 'run':10000}
and
athlete_dictionary = {'Mary':[1.204,6.6,0.32], 'John':[1.212,6.5,0.36], 'Peter':[1.14,6.6,0.38], 'Mafalda':[1.12,6.2,0.38], 'Paul':[1.24,5.6,0.4], 'Lionel':[1.201,6.0,0.3]}

= D = 

I wrote a new function triathlon_time_dict:

def triathlon_time_dict(sports,athletes_times):
    """Function inputs dictionaries sports_dictionary and athlete_dictionary and outputs an informative message about 
which participant will finish first and their expected time in hours, and which one 
will finish last and their expected time in hours.
Input: Sports(distance), athlete_times(info)
Output: participant finish(placing and times)."""
    
    sports = sports_dictionary 
    athlete_times = athlete_dictionary 
    
    distances = []
    for i in sports_dictionary:
        distances.append(sports_dictionary[i])
         #print (sports_dictionary[ i ] )

    swim_distance = np.array(distances[0])
    bike_distance = np.array(distances[1])
    run_distance = np.array(distances[2])

    value1 = athlete_dictionary.get('Mary')
    Mary_swim = value1[0]
    Mary_bike = value1[1]
    Mary_run = value1[2]
    
    value2 = athlete_dictionary.get('John')
    John_swim = value2[0]
    John_bike = value2[1]
    John_run = value2[2]
    
    value3 = athlete_dictionary.get('Peter')
    Peter_swim = value3[0]
    Peter_bike = value3[1]
    Peter_run = value3[2]
    
    value4 = athlete_dictionary.get('Mafalda')
    Mafalda_swim = value4[0]
    Mafalda_bike = value4[1]
    Mafalda_run = value4[2]
    
    
    value5 = athlete_dictionary.get('Paul')
    Paul_swim = value5[0]
    Paul_bike = value5[1]
    Paul_run = value5[2]
    
    value6 = athlete_dictionary.get('Lionel')
    Lionel_swim = value6[0]
    Lionel_bike = value6[1]
    Lionel_run = value6[2]
        
    Mary = (swim_distance/Mary_swim) + (bike_distance/Mary_bike) + (run_distance/Mary_run)
    John = (swim_distance/John_swim) + (bike_distance/John_bike) + (run_distance/John_run)
    Peter = (swim_distance/Peter_swim) + (bike_distance/Peter_bike) + (run_distance/Peter_run)
    Mafalda = (swim_distance/Mafalda_swim) + (bike_distance/Mafalda_bike) + (run_distance/Mafalda_run)
    Paul = (swim_distance/Paul_swim) + (bike_distance/Paul_bike) + (run_distance/Paul_run)
    Lionel = (swim_distance/Lionel_swim) + (bike_distance/Lionel_bike) + (run_distance/Lionel_run)
  
    total_time = np.array([Mary,John,Peter,Mafalda,Paul,Lionel])
    
    names = {'Mary':Mary, 'John':John, 'Peter':Peter, 'Mafalda':Mafalda, 'Paul':Paul, 'Lionel':Lionel}

    first_place_athlete = np.min(total_time)
    #print(np.where(total_time==first_place_athlete))

    first_place_hours = np.ceil(first_place_athlete / 360)

    last_place_athlete = np.max(total_time)
    #print(np.where(total_time==last_place_athlete))

    last_place_hours = np.ceil(last_place_athlete / 360)

    for i in names:
        if first_place_athlete == names[i]:
            name_first_place = names.keys()

    for j in names:
        if last_place_athlete == names[j]:
            name_last_place = names.keys()

    print("The first place athlete is Paul with the estimated time of", first_place_hours, 'hours.')
    print("The last place athlete is Lionel with the estimated time of", last_place_hours, "hours.")

= E =

I called both functions for the first place athlete and last place athlete and they returned the results:

The first place athlete is Paul with the estimated time of 93.0 hours.
The last place athlete is Lionel with the estimated time of 115.0 hours.

=== Problem 3 ===

= A =

#Assignment taken from PHY2049 Lab, section 00290, Lab 1: Calulating and comparing uncertainties of magentic field as a function of distance
#We were to measure the magnetic field strength at different distances, then calculate the mean, standard deviation, standard uncertanties, and t prime values for the data trials
#We were then asked to plot the mean values with error bars equal to 4*standard uncertainty for each distance, as well as a plot of the t prime values

# x is the distance in centimeters from the magnet and the detector
x = np.array([5,7.5,10,15,20,30,40,50])

#Reading in data of uT measurements 
trials = np.loadtxt("../HW9_CSmith/trials.dat")

#Finding the means of each trial of measurements 
trial1_mean = np.mean(trials[0,:])
trial2_mean = np.mean(trials[1,:])
trial3_mean = np.mean(trials[2,:])
trial4_mean = np.mean(trials[3,:])
trial5_mean = np.mean(trials[4,:])
trial6_mean = np.mean(trials[5,:])
trial7_mean = np.mean(trials[6,:])
trial8_mean = np.mean(trials[7,:])

q = np.array([trial1_mean, trial2_mean, trial3_mean, trial4_mean, trial5_mean, trial6_mean, trial7_mean, trial8_mean])

#Finding the standard deviation between the 2 trial data for each measurement (eg. at 5 cm we recorded 131.5, and 119.7 - np.std(trials[:,0]) is the standard deviation calculation of these two measurements)
trial1_stddev = np.std(trials[0,:])
trial2_stddev = np.std(trials[1,:])
trial3_stddev = np.std(trials[2,:])
trial4_stddev = np.std(trials[3,:])
trial5_stddev = np.std(trials[4,:])
trial6_stddev = np.std(trials[5,:])
trial7_stddev = np.std(trials[6,:])
trial8_stddev = np.std(trials[7,:])

#Calculating standard uncertainties 
trial1_stdun = trial1_mean / (np.sqrt(trial1_stddev))
trial2_stdun = trial2_mean / (np.sqrt(trial1_stddev))
trial3_stdun = trial3_mean / (np.sqrt(trial1_stddev))
trial4_stdun = trial4_mean / (np.sqrt(trial1_stddev))
trial5_stdun = trial5_mean / (np.sqrt(trial1_stddev))
trial6_stdun = trial6_mean / (np.sqrt(trial1_stddev))
trial7_stdun = trial7_mean / (np.sqrt(trial1_stddev))
trial8_stdun = trial8_mean / (np.sqrt(trial1_stddev))

#Calculating t' for trials in pairs (eg. trial 1 & trial 2 will be tprime_1, trial 2 & trial 3 will be tprime_2 and so on)
tprime_1 = (trial1_mean - trial2_mean)/ (np.sqrt((trial1_stdun**2)+(trial2_stdun**2)))
tprime_2 = (trial2_mean - trial3_mean)/ (np.sqrt((trial2_stdun**2)+(trial3_stdun**2)))
tprime_3 = (trial3_mean - trial4_mean)/ (np.sqrt((trial3_stdun**2)+(trial4_stdun**2)))
tprime_4 = (trial4_mean - trial5_mean)/ (np.sqrt((trial4_stdun**2)+(trial5_stdun**2)))
tprime_5 = (trial5_mean - trial6_mean)/ (np.sqrt((trial5_stdun**2)+(trial6_stdun**2)))
tprime_6 = (trial6_mean - trial7_mean)/ (np.sqrt((trial6_stdun**2)+(trial7_stdun**2)))
tprime_7 = (trial7_mean - trial8_mean)/ (np.sqrt((trial7_stdun**2)+(trial8_stdun**2)))
tprime_8 = 0

y = np.array([tprime_1, tprime_2, tprime_3, tprime_4, tprime_5, tprime_6, tprime_7, tprime_8])
z = np.array([trial1_stdun, trial2_stdun, trial3_stdun, trial4_stdun, trial5_stdun, trial6_stdun, trial7_stdun, trial8_stdun])

I took a screenshot of the original assignment and a screenshot of the finished assignment:

HW9_CSmith_Problem4_Screenshot1.png
HW9_CSmith_Problem4_Screenshot2.png

***** OUT: Sun Mar 20 19:34:20 EST 2022

***** IN: Tues Mar 22 08:45:20 EST 2022

= B = 

I plotted both the standard uncertainties (diamonds) of the trials and the t prime values (solid line), with error bars showing 4*standard uncertainty:


fig = plt.figure( figsize = (16,16) )
ax1 = fig.add_subplot(1, 1, 1)
ax2 = ax1.twinx()

ax1.plot( x, y, color= 'blue', linestyle = 'solid', label = 't prime', linewidth = 5)
ax1.legend( fontsize = 35 )
ax1.set_ylabel( 't prime', color='blue', fontsize=35, rotation = 90 )
ax1.set_xlabel('x', fontsize=35)
ax1.tick_params( axis="both", labelsize=25, length = 5 , direction = 'out') 
ax1.set_yticks( np.arange( 0,10, step = 1 ) ,fontsize=15) 
plt.xticks( np.arange( 0, 0.1, .01 ) , fontsize= 15)
    
ax2.plot( x, z,linestyle = 'none', marker = mark_syms, color = mark_color, markersize = 15)
ax2.set_ylabel( 'standard uncertainty', color='red', fontsize=35, rotation = 90 )
ax2.tick_params( axis="both", labelsize=25, length = 5 , direction = 'out') 
plt.title('The t prime and standard uncertanties of the magnetic field (uT) as a function of distance (cm)', fontsize = 35)
plt.legend()

#Error bars equaling the total of 4*standard uncertainty 
#zerror = 4*z What the error bar represents 
#z_pos = np.arange(len(z)) #How many error bars we need 
#CTEs = [q] #Sets height of error bars 
#ax2.bar(z_pos, CTEs, zerr = error)

#plt.errorbar(x, z,  zerr=zerror, fmt = '--ro', ms=10)
#plt.show()


=== Problem 4 ===

I wrote a class function named graduation_presents that uses the dimensions a,b,c of a box to calculate the box’s surface area and volume. The class returns the information regarding the amount of wrapping paper and the size of the box holding the amount of presents.

class graduation_presents:     
    def __init__(self, a = 0, b = 0, c = 0, wrap_paper_available = 0, number_of_gifts = 0):
        self.a = a
        self.b = b 
        self.c = c 
        self.wrap_paper_available = wrap_paper_available
        self.number_of_gifts = number_of_gifts 

    def surface_area(self):
        self.surface_area = ((2*self.a*self.b)+(2*self.b*self.c)+(2*self.a*self.c))
        return self.surface_area
    
    def volume(self):
        self.volume = self.a*self.b*self.c
        return self.volume
    
    def enough_paper(self):
        self.enough_paper = self.wrap_paper_available
        return self.enough_paper <= self.wrap_paper_available
            
    def fits(self): 
        return self.volume() >= self.number_of_gifts*25
    
    def print_gifts(self):
        if self.enough_paper():
            print("You have enough wrapping paper!")
        if self.fits(): 
            print("All your presents fit!")
        else:
            print("Sorry your presents will not fit")

I called it for 3 different senarios with the reported results:

grad1 = graduation_presents(10,10,10,800,15)
print(grad1.print_gifts())

You have enough wrapping paper!
All your presents fit!
None

grad2 = graduation_presents(10,10,10,1000,55)
print(grad2.print_gifts())


You have enough wrapping paper!
Sorry your presents will not fit
None

grad3 = graduation_presents(100,20,10,300,55)
print(grad3.print_gifts())

You have enough wrapping paper!
All your presents fit!
None

*** BUG NOTE:  I am not sure where exactly is the bug in this code that is returning the "none" along with the results for the functions

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_HW9_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW9_CSmith_Problem5_Screenshot3.png

I copied this log into my PHZ3150_handin_hw9_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 9 answers 

***** OUT: Tues Mar 22 14:01:00 EST 2022

***** IN: Thurs Mar 24 05:45:13 EST 2022

Start of Homework 9

=== Problem 1 ===

I created a new homework folder named HW9_CSmith:
PHZ3150_Homework_HW9_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW9_CSmith,
I imported:

import numpy as np
import math
import matplotlib.pyplot as plt

I read the chapters 16,17,18 from the online textbook listed in the PHZ3150 syllabus, "thinkpython'

=== Problem 2 ===

= A =

I created a numpy array for sports:

sports = np.array([1500, 40000, 10000])

I created a numpy array for athlete times:

athlete_times = np.array([[1,1.204,6.6,0.32],[2,1.212,6.5,0.36],[3,1.14,6.6,0.38],[4,1.12,6.2,0.38],[5,1.24,5.6,0.4],[6,1.201,6.0,0.3]])

= B = 

I wrote a function that takes as input that two arrays and outputs an informative message about which participant will finish first and their expected time in hours, and which one will finish last and their expected time in hours.

def triathlon_time(sports,athlete_times):
    """Function inputs arrays sports and athlete_times and outputs an informative message about 
which participant will finish first and their expected time in hours, and which one 
will finish last and their expected time in hours.
Input: Sports(distance), athlete_times(info)
Output: participant finish(placing and times)."""
    
    sports = sports 
    athlete_times = athlete_times

    Mary_swim = athlete_times[0,1:2]
    John_swim = athlete_times[1,1:2]
    Peter_swim = athlete_times[2,1:2]
    Mafalda_swim = athlete_times[3,1:2]
    Paul_swim = athlete_times[4,1:2]
    Lionel_swim = athlete_times[5,1:2]   
    
    Mary_bike = athlete_times[0,2:3]
    John_bike = athlete_times[1,2:3]
    Peter_bike = athlete_times[2,2:3]
    Mafalda_bike = athlete_times[3,2:3]
    Paul_bike = athlete_times[4,2:3]
    Lionel_bike = athlete_times[5,2:3]

    Mary_run = athlete_times[0,3:4]
    John_run = athlete_times[1,3:4]
    Peter_run = athlete_times[2,3:4]
    Mafalda_run = athlete_times[3,3:4]
    Paul_run = athlete_times[4,3:4]
    Lionel_run = athlete_times[5,3:4]

    swim = sports[0]
    bike = sports[1]
    run = sports[2]

    Mary = ((swim/Mary_swim)+(bike/Mary_bike)+(run/Mary_run)) 
    John = ((swim/John_swim)+(bike/John_bike)+(run/John_run)) 
    Peter = ((swim/Peter_swim)+(bike/Peter_bike)+(run/Peter_run)) 
    Mafalda = ((swim/Mafalda_swim)+(bike/Mafalda_bike)+(run/Mafalda_run)) 
    Paul = ((swim/Paul_swim)+(bike/Paul_bike)+(run/Paul_run)) 
    Lionel = ((swim/Lionel_swim)+(bike/Lionel_bike)+(run/Lionel_run)) 

    total_time = np.array([Mary,John,Peter,Mafalda,Paul,Lionel])

    names = {'Mary':Mary, 'John':John, 'Peter':Peter, 'Mafalda':Mafalda, 'Paul':Paul, 'Lionel':Lionel}

    first_place_athlete = np.min(total_time)
    #print(np.where(total_time==first_place_athlete))

    first_place_hours = np.ceil(first_place_athlete / 360)

    last_place_athlete = np.max(total_time)
    #print(np.where(total_time==last_place_athlete))

    last_place_hours = np.ceil(last_place_athlete / 360)

    print("The first place athlete is Paul with the estimated time of", first_place_hours, 'hours.')
    print("The last place athlete is Lionel with the estimated time of", last_place_hours, "hours.")

= C = 

I created two dictionaries:

sports_dictionary = {'swim':1500, 'bike':40000, 'run':10000}
and
athlete_dictionary = {'Mary':[1.204,6.6,0.32], 'John':[1.212,6.5,0.36], 'Peter':[1.14,6.6,0.38], 'Mafalda':[1.12,6.2,0.38], 'Paul':[1.24,5.6,0.4], 'Lionel':[1.201,6.0,0.3]}

= D = 

I wrote a new function triathlon_time_dict:

def triathlon_time_dict(sports,athletes_times):
    """Function inputs dictionaries sports_dictionary and athlete_dictionary and outputs an informative message about 
which participant will finish first and their expected time in hours, and which one 
will finish last and their expected time in hours.
Input: Sports(distance), athlete_times(info)
Output: participant finish(placing and times)."""
    
    sports = sports_dictionary 
    athlete_times = athlete_dictionary 
    
    distances = []
    for i in sports_dictionary:
        distances.append(sports_dictionary[i])
         #print (sports_dictionary[ i ] )

    swim_distance = np.array(distances[0])
    bike_distance = np.array(distances[1])
    run_distance = np.array(distances[2])

    value1 = athlete_dictionary.get('Mary')
    Mary_swim = value1[0]
    Mary_bike = value1[1]
    Mary_run = value1[2]
    
    value2 = athlete_dictionary.get('John')
    John_swim = value2[0]
    John_bike = value2[1]
    John_run = value2[2]
    
    value3 = athlete_dictionary.get('Peter')
    Peter_swim = value3[0]
    Peter_bike = value3[1]
    Peter_run = value3[2]
    
    value4 = athlete_dictionary.get('Mafalda')
    Mafalda_swim = value4[0]
    Mafalda_bike = value4[1]
    Mafalda_run = value4[2]
    
    
    value5 = athlete_dictionary.get('Paul')
    Paul_swim = value5[0]
    Paul_bike = value5[1]
    Paul_run = value5[2]
    
    value6 = athlete_dictionary.get('Lionel')
    Lionel_swim = value6[0]
    Lionel_bike = value6[1]
    Lionel_run = value6[2]
        
    Mary = (swim_distance/Mary_swim) + (bike_distance/Mary_bike) + (run_distance/Mary_run)
    John = (swim_distance/John_swim) + (bike_distance/John_bike) + (run_distance/John_run)
    Peter = (swim_distance/Peter_swim) + (bike_distance/Peter_bike) + (run_distance/Peter_run)
    Mafalda = (swim_distance/Mafalda_swim) + (bike_distance/Mafalda_bike) + (run_distance/Mafalda_run)
    Paul = (swim_distance/Paul_swim) + (bike_distance/Paul_bike) + (run_distance/Paul_run)
    Lionel = (swim_distance/Lionel_swim) + (bike_distance/Lionel_bike) + (run_distance/Lionel_run)
  
    total_time = np.array([Mary,John,Peter,Mafalda,Paul,Lionel])
    
    names = {'Mary':Mary, 'John':John, 'Peter':Peter, 'Mafalda':Mafalda, 'Paul':Paul, 'Lionel':Lionel}

    first_place_athlete = np.min(total_time)
    #print(np.where(total_time==first_place_athlete))

    first_place_hours = np.ceil(first_place_athlete / 360)

    last_place_athlete = np.max(total_time)
    #print(np.where(total_time==last_place_athlete))

    last_place_hours = np.ceil(last_place_athlete / 360)

    for i in names:
        if first_place_athlete == names[i]:
            name_first_place = names.keys()

    for j in names:
        if last_place_athlete == names[j]:
            name_last_place = names.keys()

    print("The first place athlete is Paul with the estimated time of", first_place_hours, 'hours.')
    print("The last place athlete is Lionel with the estimated time of", last_place_hours, "hours.")

= E =

I called both functions for the first place athlete and last place athlete and they returned the results:

The first place athlete is Paul with the estimated time of 93.0 hours.
The last place athlete is Lionel with the estimated time of 115.0 hours.

****BUG NOTE: In both triathlon_times and triathlon_times_dict the code does not call the name of the first and last place athlete directly (I was able to assertain who was first and last by using the np.where function- I have commented out this code in the functions)
I have a midterm in ODEs and also Physics 2 this week and I simply just ran out of time to go back and address this bug. 

=== Problem 3 ===

= A =

#Assignment taken from PHY2049 Lab, section 00290, Lab 1: Calulating and comparing uncertainties of magentic field as a function of distance
#We were to measure the magnetic field strength at different distances, then calculate the mean, standard deviation, standard uncertanties, and t prime values for the data trials
#We were then asked to plot the mean values with error bars equal to 4*standard uncertainty for each distance, as well as a plot of the t prime values

I took screenshots of the assignment and the problem solved in the class:


HW9_CSmith_Problem4_Screenshot1.png
HW9_CSmith_Problem4_Screenshot2.png

I created a function named mean that takes the distance and magnetic field strength measurements of a simple magnet and returns mean.
I created a function named t_prime that takes the distance and magnetic field strength measurements of a simple magnet, calls for the mean and standard deviation using numpy, and returns t prime calulations.
I created a function named error_bars that  the distance and magnetic field strength measurements of a simple magnet, calls for the mean and standard deviation using numpy, calculates the standard uncertainty, and that computes the error bars set to be 4* the standard uncertainty.

I then called these three functions:

trial1 = np.array([119.7,81.5,64.1,49.9,46.2,44.9,44.4,44.4])
trial2 = np.array([131.5,108.4,71.43,54.0,46.9,42.7,42.0,41.8])
distance = [5,7.5,10,15,20,30,40,50]
q = mean(distance, trial1, trial2)
y = t_prime(distance, trial1, trial2)
error = error_bars(distance, trial1, trial2)

= B = 

I plotted both the standard uncertainties (diamonds) of the trials and the t prime values (solid line), with error bars showing 4*standard uncertainty:


fig = plt.figure( figsize = (16,16) )
ax1 = fig.add_subplot(1, 1, 1)
ax2 = ax1.twinx()

ax1.plot( x, y, color= 'blue', linestyle = 'solid', label = 't prime', linewidth = 5)
ax1.legend( fontsize = 35 )
ax1.set_ylabel( 't prime', color='blue', fontsize=35, rotation = 90 )
ax1.set_xlabel('x', fontsize=35)
ax1.tick_params( axis="both", labelsize=25, length = 5 , direction = 'out') 
ax1.set_yticks( np.arange( 0,10, step = 1 ) ,fontsize=15) 
plt.xticks( np.arange( 0, 0.1, .01 ) , fontsize= 15)
    
ax2.plot( x, z,linestyle = 'none', marker = mark_syms, color = mark_color, markersize = 15)
ax2.set_ylabel( 'standard uncertainty', color='red', fontsize=35, rotation = 90 )
ax2.tick_params( axis="both", labelsize=25, length = 5 , direction = 'out') 
plt.title('The t prime and standard uncertanties of the magnetic field (uT) as a function of distance (cm)', fontsize = 35)
plt.legend()

#Error bars equaling the total of 4*standard uncertainty 
#zerror = 4*z What the error bar represents 
#z_pos = np.arange(len(z)) #How many error bars we need 
#CTEs = [q] #Sets height of error bars 
#ax2.bar(z_pos, CTEs, zerr = error)

#plt.errorbar(x, z,  zerr=zerror, fmt = '--ro', ms=10)
#plt.show()


=== Problem 4 ===

I wrote a class function named graduation_presents that uses the dimensions a,b,c of a box to calculate the box’s surface area and volume. The class returns the information regarding the amount of wrapping paper and the size of the box holding the amount of presents.

class graduation_presents:     
    def __init__(self, a = 0, b = 0, c = 0, wrap_paper_available = 0, number_of_gifts = 0):
        self.a = a
        self.b = b 
        self.c = c 
        self.wrap_paper_available = wrap_paper_available
        self.number_of_gifts = number_of_gifts 

    def surface_area(self):
        self.surface_area = ((2*self.a*self.b)+(2*self.b*self.c)+(2*self.a*self.c))
        return self.surface_area
    
    def volume(self):
        self.volume = self.a*self.b*self.c
        return self.volume
    
    def enough_paper(self):
        self.enough_paper = self.wrap_paper_available
        return self.enough_paper <= self.wrap_paper_available
            
    def fits(self): 
        return self.volume() >= self.number_of_gifts*25
    
    def print_gifts(self):
        if self.enough_paper():
            print("You have enough wrapping paper!")
        if self.fits(): 
            print("All your presents fit!")
        else:
            print("Sorry your presents will not fit")

I called it for 3 different senarios with the reported results:

grad1 = graduation_presents(10,10,10,800,15)
print(grad1.print_gifts())

You have enough wrapping paper!
All your presents fit!
None

grad2 = graduation_presents(10,10,10,1000,55)
print(grad2.print_gifts())


You have enough wrapping paper!
Sorry your presents will not fit
None

grad3 = graduation_presents(100,20,10,300,55)
print(grad3.print_gifts())

You have enough wrapping paper!
All your presents fit!
None

*** BUG NOTE:  I am not sure where exactly is the bug in this code that is returning the "none" along with the results for the functions

=== Problem 5 ===

I copied my finalized jupyter notebook to my handin_HW9_CSmith folder, then comitted it in the Github desktop app and pushed the changes to origin. 

Screen capture was taken via snapshot command WINDOWS+SHIFT+S and saved as:

HW9_CSmith_Problem5_Screenshot3.png

I copied this log into my PHZ3150_handin_hw9_CSmith folder, then zipped the folder, and uploaded the zipped file to webcourses.

End of Homework 9 answers 

***** OUT: Thurs Mar 22 05:47:45 EST 2022

***** IN: Fri Mar 25 14:19:27 EST 2022.


Start of Homework 10

=== Problem 1 ===

I created a new homework folder named HW10_CSmith:
PHZ3150_Homework_HW10_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW10_CSmith,
I imported:

import numpy as np
import math
import matplotlib.pyplot as plt
import pdb

=== Problem 2 ====

I copied the 'buggy' code from the link listed in the assignment:

https://colab.research.google.com/drive/1lGjSv4inSuYzoo9lewXvy0KH7XLvris5?usp=sh
aring 

#I inserted brackets around the multiplication of (0*my_data) to ensure correct arthematic order of operations was followed 
#I had to define what i and j meant for my_data, and in order to achieve all possible combinations of i and j, I wrote in a for loop for i an j in range(len(my_data))
#I checked that the results were reasonable by printing print(rel_dif) to check that the loops worked as they should
#I checked using a print(my_data[i,j]) to check that the masking worked correctly, and initally it did not it printed results not within the set parameters. 
#There was a coding error in which the programmer forgot to add in the elif statement checking for data that is above 25% relative error.  I added this elif statement in. 

For the plot:

#Added second = in loop 3 to make it a logical statement ( if data_control[i,j] == 3)
#In the fourth loop the marker and color was not added if data_control[i,j]==4

=== Problem 3 === 

I created a function takes in input about choice of circuit (series or parallel), number of resistors, and array of resistances, and the voltage.

My code asks the user to input which type of circuit they would like (series or parallel), and then runs through a for/if/else loop to calculate the total resistance, voltage(series) and current(parallel). 

For the parallel circuits it takes the # of resistors, the resistances of the resistors, the voltage, and returns the statement:

For a parallel circuit, the total resistance with 3 resistors that you chose is 3.0 Ohms, and with 15.0  Volts voltage, the total current is 5.0 Amperes!

For the series circuits it takes the # of resistors, the resistances of the resistors, the current, and returns the statement:

For a series circuit the total resistance with the 3 resistors that you chose is 14.0 Ohms, and with 10.0 Amperes current, the total voltage is 140.0 Volts!

=== Problem 4 ===

I created a dictionary names planets, and populated it with Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus and Neptune as keys, and their distances from the sun in AU as the values.

= A = 

I created a function called period, that calculates the rotational period of a planet when its average orbital distance 'a' is known using Kepler's 3rd law.

This function calls the values from the dictionary planets and returns the period of each planet:

def period(name):
    """Calculates the rotational period of a planet when its average orbital distance a  is known using Kepler's 3rd law
    Input: average distance from sun (a) in AU
    Ouput: orbital period (p)."""
    
    a = planets[name]
    
    p = np.round(np.sqrt(a**3), 2)
    
    return p

I called the code for each of the planets and it returned:

0.24
0.61
1.0
1.87
11.86
29.47
84.13
164.81

***** OUT: Fri Mar 25 18:01:31 EST 2022

***** IN: Tues Mar 29 06:09:41 EST 2022

=== Problem 4 ===

= A =

I wrote code that calculates all possible planetary using the raidus given and the calculated period to calculate and plot the orbits of the planets.
This used the parametic equations:

radius_Mercury = 0.39
n = 1000
phi =np.linspace(0,2*np.pi,n)
theta = np.zeros([n])
x1 = np.zeros([n])
y1 = np.zeros([n])
for i in range(0,n):
    x1[i] = radius_Mercury*np.cos(phi[i])
for i in range(0,n):
    y1[i] = radius_Mercury*np.sin(phi[i])
    #print(x,y)   

This is a sample of the code used for all eight planets for all possible combinations (x[i],y[j]).

The plot was saved as a .png file named hw10_CSmith.png:

plt.savefig( 'hw10_CSmith.png', format = 'png', dpi = 100, bbox_inches = 'tight', pad_inches = 0.3 )

= B = 

I am presenting at OUR research week and didnt have time to complete the extra credit problem this week.

***** OUT: Mar 29 07:32:56 EST 2022

***** IN: Thurs Mar 31 10:43:02 EST 2022

Start of Homework 10

=== Problem 1 ===

I created a new homework folder named HW10_CSmith:
PHZ3150_Homework_HW10_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW10_CSmith,
I imported:

import numpy as np
import math
import matplotlib.pyplot as plt
import pdb

=== Problem 2 ====

I copied the 'buggy' code from the link listed in the assignment:

https://colab.research.google.com/drive/1lGjSv4inSuYzoo9lewXvy0KH7XLvris5?usp=sh
aring 
I removed the period behind the 0 in the mask data_control. If wasnt a bug just unnessecary for the code since the output are all supposed to be single digit integers
I inserted brackets around the multiplication of (0*my_data) to ensure correct arthematic order of operations was followed 
I changed the first loop to range(len(my_control_data)) to be clear on what data set is exactly being looped over 
I had to define what i and j meant for my_data, and in order to achieve all possible combinations of i and j, I wrote in a for loop for i an j in range(len(my_data))
I changed the variables from l1 and l2 to i and j, so that in the loops that are masking the values of the relative errors it is consistent
I checked that the results were reasonable by printing print(rel_dif) and print(data_control) to check that the loops worked as they should
I checked using a print(my_data[i,j]) to check that the masking worked correctly, and initally it did not it printed results not within the set parameters. 
I changed the first data mask from rel_dif <= .15 which as it is written also includes negative values which is not what was meant, to rel_dif > 0 and rel_dif <= 0.15
There was a coding error in which the programmer forgot to add in the elif statement checking for data that is above 25% relative error.  I added this elif statement in. 
I changed the last loop in the masking of rel_div to simply read if rel_dif <= 0, as we are not interested in relative differences that are negative (sign flip), and the = will classify any data points in the sets that are 0

While the code does run, I am not certain that it is running completely correctly and that I have addressed all the bugs as it only returns one value as being within the standards of good data (1)
For the plot:

Added second = in loop 3 to make it a logical statement ( if data_control[i,j] == 3)
In the fourth loop the marker and color was not added if data_control[i,j]==4
I checked that the axis were correct using print statements for the max_xy and min_xy values 
I changed loop to read range(len(data_control))
I changed the step size on the x and y axis to 8 from 24 to make it more reader friendly 

The plot appears to have plotted the values correctly from data_control, I am not certain what exactly the x-axis should be labeled or what values it should have to make more sense in this circumstance

=== Problem 3 === 

I created a function takes in input about choice of circuit (series or parallel), number of resistors, and array of resistances, and the voltage.

My code asks the user to input which type of circuit they would like (series or parallel), and then runs through a for/if/else loop to calculate the total resistance, voltage(series) and current(parallel). 

For the parallel circuits it takes the # of resistors, the resistances of the resistors, the voltage, and returns the statement:

For a parallel circuit, the total resistance with 3 resistors that you chose is 3.0 Ohms, and with 15.0  Volts voltage, the total current is 5.0 Amperes!

For the series circuits it takes the # of resistors, the resistances of the resistors, the current, and returns the statement:

For a series circuit the total resistance with the 3 resistors that you chose is 14.0 Ohms, and with 10.0 Amperes current, the total voltage is 140.0 Volts!

=== Problem 4 ===

I created a dictionary names planets, and populated it with Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus and Neptune as keys, and their distances from the sun in AU as the values.

= A = 

I created a function called period, that calculates the rotational period of a planet when its average orbital distance 'a' is known using Kepler's 3rd law.

This function calls the values from the dictionary planets and returns the period of each planet:

def period(name):
    """Calculates the rotational period of a planet when its average orbital distance a  is known using Kepler's 3rd law
    Input: average distance from sun (a) in AU
    Ouput: orbital period (p)."""
    
    a = planets[name]
    
    p = np.round(np.sqrt(a**3), 2)
    
    return p

I called the code for each of the planets and it returned:

0.24
0.61
1.0
1.87
11.86
29.47
84.13
164.81

I wrote code that calculates all possible planetary using the raidus given and the calculated period to calculate and plot the orbits of the planets.
This used the parametic equations:

radius_Mercury = 0.39
n = 1000
phi =np.linspace(0,2*np.pi,n)
theta = np.zeros([n])
x1 = np.zeros([n])
y1 = np.zeros([n])
for i in range(0,n):
    x1[i] = radius_Mercury*np.cos(phi[i])
for i in range(0,n):
    y1[i] = radius_Mercury*np.sin(phi[i])
    #print(x,y)   

This is a sample of the code used for all eight planets for all possible combinations (x[i],y[j]).

The plot was saved as a .png file named hw10_CSmith.png:

plt.savefig( 'hw10_CSmith.png', format = 'png', dpi = 100, bbox_inches = 'tight', pad_inches = 0.3 )

= B = 

I am presenting at OUR research week and didnt have time to complete the extra credit problem this week.

***** OUT: Thurs Mar 31 11:01:47 EST 2022

***** IN: Fri April 1 14:12:03 EST 2022

Start of Homework 11

=== Problem 1 ===

I created a new homework folder named HW11_CSmith:
PHZ3150_Homework_HW11_CSmith

I backed this folder up on the Github desktop app, and pushed the changes to the origin.

I created a new Jupyter notebook, renamed it as HW11_CSmith,
I imported:

import numpy as np
import math
import scipy as sp
import matplotlib.pyplot as plt

=== Problem 2 === 

I wrote a code that looks for all possible combinations of the given arays a and b and returns the parameters a and b that best fit the given data for a linear function.
First I made a numpy array of zeros in the lengths of a and b aranges.
Next I looped through both a and b arrays to obtain all possible combinations of a and b for the linear function y_theory = a[i]*x+b[j]
I then took the chi square value which determines the combination of a and b that has the least error in relationship to the data.
I then used np.where to located the minimum chi square value, named q.
Next I printed the aq[0] and bq[1] values with the informative statement:

The best fit model parameters for this linear function are, a: [3.2] and b: [4.5]

=== Problem 3 ===

= A = 

I created a function called windchill that calculates the windchill factor in Farenheit from the actual measured temperature in Fahrenheit and the windspeed in mph.
In addition to the value it also prints an informative statement.

I called the function for the temperature of 20 and the windspeed of 55 and it return:

If the actual temperature measured in Fahrenheit is 20 and the windspeed in mph is 55 then the windchill temperature is -3.47 degrees Fahrenheit!

= B = 

I created a function parallax_to_distance that takes as input a dictionary with the information of the star name and the parallax, and returns to it the distance.
I then called the function for the dictionary:

star_parallax = {'Betelgeuse':7.63, 'Antares':5.89, 'Spica':13.06, 'Proxima_Cen':768}

And it returned the results:

{'Betelgeuse': 0.1310615989515072, 'Antares': 0.16977928692699493, 'Spica': 0.07656967840735068, 'Proxima_Cen': 0.0013020833333333333}

I confirmed these results by hand with a graphing calulator 

= C = 

I created a function lists_to_dict that takes as input two lists and combines them into a new dictionary with the keys as the words and the values as the numbers.

I then called the function for two different sets of lists:

list_1 = [ 1, 3, 5, 10, 12, 14]   
list_2 = ['watermelon', 'melon', 'apple', 'strawberries', 'cherries', 'oranges']

returning:

{'watermelon': 1, 'melon': 3, 'apple': 5, 'strawberries': 10, 'cherries': 12, 'oranges': 14}

and 

list_1 = ['cars', 'motorcycles', 'bikes', 'skateboards']
list_2 = [ 200, 150, 10, 67 ] 

returning:

{'cars': 200, 'motorcycles': 150, 'bikes': 10, 'skateboards': 67}

= D = 

I created a function matrix_mult that takes as input two matrices and multiplies them after first checking to see if the matrices have the same dimensions and can be multiplied.

I called the function for:

A1 = np.array([[1,2,3],[4,5,6]]) 
A2 = np.array([[2,3],[2,2]]) 
returning the result: 
Unable to perform matrix multiplication as matrices are not of equal dimensions

I checked that the function returns the correct error for mismatching dimensions by using the numpy matmul function

B1 = np.array([[1,0],[0,1]]) 
B2 = np.array([[4,1],[2,1]])
returning the result:

The result of your matrix multiplication is:
[4, 1]
[2, 1]

I checked that the function output is correct using the numpy matmul function

C1 = np.array([[1,0,3],[0,1,4],[2,1,8]]) 
C2 = np.array([4,1,5]) 
returning the result:Unable to perform matrix multiplication as matrices are not of equal dimensions

I checked that the function returns the correct error for mismatching dimensions by using the numpy matmul function 

***** OUT: Fri April 1 17:51:46 EST 2022